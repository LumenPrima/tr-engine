// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: unit_events.sql

package sqlcdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertUnitEvent = `-- name: InsertUnitEvent :exec
INSERT INTO unit_events (
    event_type, system_id, unit_rid, "time", tgid,
    unit_alpha_tag, tg_alpha_tag, call_num, freq,
    start_time, stop_time, encrypted, emergency,
    "position", length, error_count, spike_count, sample_count,
    transmission_filename, talkgroup_patches,
    instance_id, sys_num, sys_name,
    incidentdata
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9,
    $10, $11, $12, $13,
    $14, $15, $16, $17, $18,
    $19, $20,
    $21, $22, $23,
    $24
)
`

type InsertUnitEventParams struct {
	EventType            string
	SystemID             int
	UnitRid              int
	Time                 pgtype.Timestamptz
	Tgid                 *int32
	UnitAlphaTag         *string
	TgAlphaTag           *string
	CallNum              *int32
	Freq                 *int64
	StartTime            pgtype.Timestamptz
	StopTime             pgtype.Timestamptz
	Encrypted            *bool
	Emergency            *bool
	Position             *float32
	Length               *float32
	ErrorCount           *int32
	SpikeCount           *int32
	SampleCount          *int32
	TransmissionFilename *string
	TalkgroupPatches     []int
	InstanceID           *string
	SysNum               *int16
	SysName              *string
	Incidentdata         []byte
}

func (q *Queries) InsertUnitEvent(ctx context.Context, arg InsertUnitEventParams) error {
	_, err := q.db.Exec(ctx, insertUnitEvent,
		arg.EventType,
		arg.SystemID,
		arg.UnitRid,
		arg.Time,
		arg.Tgid,
		arg.UnitAlphaTag,
		arg.TgAlphaTag,
		arg.CallNum,
		arg.Freq,
		arg.StartTime,
		arg.StopTime,
		arg.Encrypted,
		arg.Emergency,
		arg.Position,
		arg.Length,
		arg.ErrorCount,
		arg.SpikeCount,
		arg.SampleCount,
		arg.TransmissionFilename,
		arg.TalkgroupPatches,
		arg.InstanceID,
		arg.SysNum,
		arg.SysName,
		arg.Incidentdata,
	)
	return err
}

const loadRecentAffiliations = `-- name: LoadRecentAffiliations :many
WITH latest_joins AS (
    SELECT DISTINCT ON (ue.system_id, ue.unit_rid)
        ue.system_id, ue.unit_rid, ue.tgid,
        COALESCE(u.alpha_tag, ue.unit_alpha_tag, '') AS unit_alpha_tag,
        COALESCE(tg.alpha_tag, ue.tg_alpha_tag, '') AS tg_alpha_tag,
        COALESCE(tg.description, '') AS tg_description,
        COALESCE(tg.tag, '') AS tg_tag,
        COALESCE(tg."group", '') AS tg_group,
        COALESCE(s.name, '') AS system_name, COALESCE(s.sysid, '') AS sysid,
        ue."time"
    FROM unit_events ue
    JOIN systems s ON s.system_id = ue.system_id
    LEFT JOIN units u ON u.system_id = ue.system_id AND u.unit_id = ue.unit_rid
    LEFT JOIN talkgroups tg ON tg.system_id = ue.system_id AND tg.tgid = ue.tgid
    WHERE ue.event_type = 'join'
      AND ue."time" > now() - interval '24 hours'
      AND ue.tgid IS NOT NULL
    ORDER BY ue.system_id, ue.unit_rid, ue."time" DESC
)
SELECT lj.system_id, lj.unit_rid, lj.tgid, lj.unit_alpha_tag, lj.tg_alpha_tag, lj.tg_description, lj.tg_tag, lj.tg_group, lj.system_name, lj.sysid, lj.time, EXISTS(
    SELECT 1 FROM unit_events ev
    WHERE ev.system_id = lj.system_id
      AND ev.unit_rid = lj.unit_rid
      AND ev."time" > lj."time"
      AND ev."time" > now() - interval '24 hours'
      AND (
        ev.event_type = 'off'
        OR (ev.event_type IN ('call', 'end', 'location')
            AND ev.tgid IS NOT NULL AND ev.tgid != lj.tgid)
      )
) AS went_off
FROM latest_joins lj
`

type LoadRecentAffiliationsRow struct {
	SystemID      int
	UnitRid       int
	Tgid          *int32
	UnitAlphaTag  string
	TgAlphaTag    string
	TgDescription string
	TgTag         string
	TgGroup       string
	SystemName    string
	Sysid         string
	Time          pgtype.Timestamptz
	WentOff       bool
}

func (q *Queries) LoadRecentAffiliations(ctx context.Context) ([]LoadRecentAffiliationsRow, error) {
	rows, err := q.db.Query(ctx, loadRecentAffiliations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoadRecentAffiliationsRow{}
	for rows.Next() {
		var i LoadRecentAffiliationsRow
		if err := rows.Scan(
			&i.SystemID,
			&i.UnitRid,
			&i.Tgid,
			&i.UnitAlphaTag,
			&i.TgAlphaTag,
			&i.TgDescription,
			&i.TgTag,
			&i.TgGroup,
			&i.SystemName,
			&i.Sysid,
			&i.Time,
			&i.WentOff,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
