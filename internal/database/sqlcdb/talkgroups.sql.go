// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: talkgroups.sql

package sqlcdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const enrichTalkgroupsFromDirectory = `-- name: EnrichTalkgroupsFromDirectory :execrows
UPDATE talkgroups t SET
    alpha_tag   = CASE WHEN COALESCE(t.alpha_tag_source, '') = 'manual' THEN t.alpha_tag
                       ELSE COALESCE(NULLIF(t.alpha_tag, ''), td.alpha_tag) END,
    alpha_tag_source = CASE WHEN COALESCE(t.alpha_tag_source, '') = 'manual' THEN t.alpha_tag_source
                            WHEN COALESCE(t.alpha_tag, '') = '' AND COALESCE(td.alpha_tag, '') <> '' THEN 'csv'
                            ELSE t.alpha_tag_source END,
    tag         = COALESCE(NULLIF(t.tag, ''), td.tag),
    "group"     = COALESCE(NULLIF(t."group", ''), td.category),
    description = COALESCE(NULLIF(t.description, ''), td.description),
    mode        = COALESCE(t.mode, td.mode),
    priority    = COALESCE(t.priority, td.priority)
FROM talkgroup_directory td
WHERE td.system_id = t.system_id AND td.tgid = t.tgid
  AND t.system_id = $1
  AND ($2::int = 0 OR t.tgid = $2)
`

type EnrichTalkgroupsFromDirectoryParams struct {
	SystemID int
	Tgid     int
}

func (q *Queries) EnrichTalkgroupsFromDirectory(ctx context.Context, arg EnrichTalkgroupsFromDirectoryParams) (int64, error) {
	result, err := q.db.Exec(ctx, enrichTalkgroupsFromDirectory, arg.SystemID, arg.Tgid)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findTalkgroupSystems = `-- name: FindTalkgroupSystems :many
SELECT t.system_id, COALESCE(s.name, '') AS system_name, s.sysid
FROM talkgroups t
JOIN systems s ON s.system_id = t.system_id AND s.deleted_at IS NULL
WHERE t.tgid = $1
`

type FindTalkgroupSystemsRow struct {
	SystemID   int
	SystemName string
	Sysid      string
}

func (q *Queries) FindTalkgroupSystems(ctx context.Context, tgid int) ([]FindTalkgroupSystemsRow, error) {
	rows, err := q.db.Query(ctx, findTalkgroupSystems, tgid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindTalkgroupSystemsRow{}
	for rows.Next() {
		var i FindTalkgroupSystemsRow
		if err := rows.Scan(&i.SystemID, &i.SystemName, &i.Sysid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTalkgroupByComposite = `-- name: GetTalkgroupByComposite :one
SELECT t.system_id, COALESCE(s.name, '') AS system_name, s.sysid,
    t.tgid, COALESCE(t.alpha_tag, '') AS alpha_tag, COALESCE(t.tag, '') AS tag,
    COALESCE(t."group", '') AS "group", COALESCE(t.description, '') AS description,
    t.mode, t.priority, t.first_seen, t.last_seen,
    (SELECT count(*) FROM calls c WHERE c.system_id = t.system_id AND c.tgid = t.tgid AND c.start_time > now() - interval '30 days')::int AS call_count,
    (SELECT count(*) FROM calls c WHERE c.system_id = t.system_id AND c.tgid = t.tgid AND c.start_time > now() - interval '1 hour')::int AS calls_1h,
    (SELECT count(*) FROM calls c WHERE c.system_id = t.system_id AND c.tgid = t.tgid AND c.start_time > now() - interval '24 hours')::int AS calls_24h,
    (SELECT count(DISTINCT u) FROM calls c, unnest(c.unit_ids) AS u
        WHERE c.system_id = t.system_id AND c.tgid = t.tgid AND c.start_time > now() - interval '30 days')::int AS unit_count
FROM talkgroups t
JOIN systems s ON s.system_id = t.system_id
WHERE t.system_id = $1 AND t.tgid = $2
`

type GetTalkgroupByCompositeParams struct {
	SystemID int
	Tgid     int
}

type GetTalkgroupByCompositeRow struct {
	SystemID    int
	SystemName  string
	Sysid       string
	Tgid        int
	AlphaTag    string
	Tag         string
	Group       string
	Description string
	Mode        *string
	Priority    *int32
	FirstSeen   pgtype.Timestamptz
	LastSeen    pgtype.Timestamptz
	CallCount   int
	Calls1h     int
	Calls24h    int
	UnitCount   int
}

func (q *Queries) GetTalkgroupByComposite(ctx context.Context, arg GetTalkgroupByCompositeParams) (GetTalkgroupByCompositeRow, error) {
	row := q.db.QueryRow(ctx, getTalkgroupByComposite, arg.SystemID, arg.Tgid)
	var i GetTalkgroupByCompositeRow
	err := row.Scan(
		&i.SystemID,
		&i.SystemName,
		&i.Sysid,
		&i.Tgid,
		&i.AlphaTag,
		&i.Tag,
		&i.Group,
		&i.Description,
		&i.Mode,
		&i.Priority,
		&i.FirstSeen,
		&i.LastSeen,
		&i.CallCount,
		&i.Calls1h,
		&i.Calls24h,
		&i.UnitCount,
	)
	return i, err
}

const updateTalkgroupFields = `-- name: UpdateTalkgroupFields :exec
UPDATE talkgroups SET
    alpha_tag        = CASE WHEN $1::text <> '' THEN $1 ELSE alpha_tag END,
    alpha_tag_source = CASE WHEN $2::text <> '' THEN $2 ELSE alpha_tag_source END,
    description = CASE WHEN $3::text <> '' THEN $3 ELSE description END,
    "group"     = CASE WHEN $4::text <> '' THEN $4 ELSE "group" END,
    tag         = CASE WHEN $5::text <> '' THEN $5 ELSE tag END,
    priority    = CASE WHEN $6::int >= 0 THEN $6 ELSE priority END
WHERE system_id = $7 AND tgid = $8
`

type UpdateTalkgroupFieldsParams struct {
	AlphaTag       string
	AlphaTagSource string
	Description    string
	TgGroup        string
	Tag            string
	Priority       int
	SystemID       int
	Tgid           int
}

func (q *Queries) UpdateTalkgroupFields(ctx context.Context, arg UpdateTalkgroupFieldsParams) error {
	_, err := q.db.Exec(ctx, updateTalkgroupFields,
		arg.AlphaTag,
		arg.AlphaTagSource,
		arg.Description,
		arg.TgGroup,
		arg.Tag,
		arg.Priority,
		arg.SystemID,
		arg.Tgid,
	)
	return err
}

const upsertTalkgroup = `-- name: UpsertTalkgroup :exec
INSERT INTO talkgroups (system_id, tgid, alpha_tag, tag, "group", description, first_seen, last_seen)
VALUES ($1, $2, $3, $4, $5, $6, $7, $7)
ON CONFLICT (system_id, tgid) DO UPDATE SET
    alpha_tag   = CASE WHEN COALESCE(talkgroups.alpha_tag_source, '') = 'manual' THEN talkgroups.alpha_tag
                       ELSE COALESCE(NULLIF($3, ''), talkgroups.alpha_tag) END,
    tag         = COALESCE(NULLIF($4, ''), talkgroups.tag),
    "group"     = COALESCE(NULLIF($5, ''), talkgroups."group"),
    description = COALESCE(NULLIF($6, ''), talkgroups.description),
    first_seen  = LEAST(talkgroups.first_seen, $7),
    last_seen   = GREATEST(talkgroups.last_seen, $7)
`

type UpsertTalkgroupParams struct {
	SystemID    int
	Tgid        int
	AlphaTag    *string
	Tag         *string
	TgGroup     *string
	Description *string
	EventTime   pgtype.Timestamptz
}

func (q *Queries) UpsertTalkgroup(ctx context.Context, arg UpsertTalkgroupParams) error {
	_, err := q.db.Exec(ctx, upsertTalkgroup,
		arg.SystemID,
		arg.Tgid,
		arg.AlphaTag,
		arg.Tag,
		arg.TgGroup,
		arg.Description,
		arg.EventTime,
	)
	return err
}

const upsertTalkgroupDirectory = `-- name: UpsertTalkgroupDirectory :exec
INSERT INTO talkgroup_directory (system_id, tgid, alpha_tag, mode, description, tag, category, priority)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (system_id, tgid) DO UPDATE SET
    alpha_tag   = COALESCE(NULLIF($3, ''), talkgroup_directory.alpha_tag),
    mode        = COALESCE(NULLIF($4, ''), talkgroup_directory.mode),
    description = COALESCE(NULLIF($5, ''), talkgroup_directory.description),
    tag         = COALESCE(NULLIF($6, ''), talkgroup_directory.tag),
    category    = COALESCE(NULLIF($7, ''), talkgroup_directory.category),
    priority    = COALESCE($8, talkgroup_directory.priority),
    imported_at = now()
`

type UpsertTalkgroupDirectoryParams struct {
	SystemID    int
	Tgid        int
	AlphaTag    *string
	Mode        *string
	Description *string
	Tag         *string
	Category    *string
	Priority    *int32
}

func (q *Queries) UpsertTalkgroupDirectory(ctx context.Context, arg UpsertTalkgroupDirectoryParams) error {
	_, err := q.db.Exec(ctx, upsertTalkgroupDirectory,
		arg.SystemID,
		arg.Tgid,
		arg.AlphaTag,
		arg.Mode,
		arg.Description,
		arg.Tag,
		arg.Category,
		arg.Priority,
	)
	return err
}
