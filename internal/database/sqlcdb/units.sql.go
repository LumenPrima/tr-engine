// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: units.sql

package sqlcdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findUnitSystems = `-- name: FindUnitSystems :many
SELECT u.system_id, COALESCE(s.name, '') AS system_name, s.sysid
FROM units u
JOIN systems s ON s.system_id = u.system_id AND s.deleted_at IS NULL
WHERE u.unit_id = $1
`

type FindUnitSystemsRow struct {
	SystemID   int
	SystemName string
	Sysid      string
}

func (q *Queries) FindUnitSystems(ctx context.Context, unitID int) ([]FindUnitSystemsRow, error) {
	rows, err := q.db.Query(ctx, findUnitSystems, unitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindUnitSystemsRow{}
	for rows.Next() {
		var i FindUnitSystemsRow
		if err := rows.Scan(&i.SystemID, &i.SystemName, &i.Sysid); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnitByComposite = `-- name: GetUnitByComposite :one
SELECT u.system_id, COALESCE(s.name, '') AS system_name, s.sysid,
    u.unit_id, COALESCE(u.alpha_tag, '') AS alpha_tag, COALESCE(u.alpha_tag_source, '') AS alpha_tag_source,
    u.first_seen, u.last_seen,
    u.last_event_type, u.last_event_time, u.last_event_tgid,
    COALESCE(tg.alpha_tag, '') AS last_event_tg_tag
FROM units u
JOIN systems s ON s.system_id = u.system_id
LEFT JOIN talkgroups tg ON tg.system_id = u.system_id AND tg.tgid = u.last_event_tgid
WHERE u.system_id = $1 AND u.unit_id = $2
`

type GetUnitByCompositeParams struct {
	SystemID int
	UnitID   int
}

type GetUnitByCompositeRow struct {
	SystemID       int
	SystemName     string
	Sysid          string
	UnitID         int
	AlphaTag       string
	AlphaTagSource string
	FirstSeen      pgtype.Timestamptz
	LastSeen       pgtype.Timestamptz
	LastEventType  *string
	LastEventTime  pgtype.Timestamptz
	LastEventTgid  *int32
	LastEventTgTag string
}

func (q *Queries) GetUnitByComposite(ctx context.Context, arg GetUnitByCompositeParams) (GetUnitByCompositeRow, error) {
	row := q.db.QueryRow(ctx, getUnitByComposite, arg.SystemID, arg.UnitID)
	var i GetUnitByCompositeRow
	err := row.Scan(
		&i.SystemID,
		&i.SystemName,
		&i.Sysid,
		&i.UnitID,
		&i.AlphaTag,
		&i.AlphaTagSource,
		&i.FirstSeen,
		&i.LastSeen,
		&i.LastEventType,
		&i.LastEventTime,
		&i.LastEventTgid,
		&i.LastEventTgTag,
	)
	return i, err
}

const updateUnitFields = `-- name: UpdateUnitFields :exec
UPDATE units SET
    alpha_tag        = CASE WHEN $1::text <> '' THEN $1 ELSE alpha_tag END,
    alpha_tag_source = CASE WHEN $2::text <> '' THEN $2 ELSE alpha_tag_source END
WHERE system_id = $3 AND unit_id = $4
`

type UpdateUnitFieldsParams struct {
	AlphaTag       string
	AlphaTagSource string
	SystemID       int
	UnitID         int
}

func (q *Queries) UpdateUnitFields(ctx context.Context, arg UpdateUnitFieldsParams) error {
	_, err := q.db.Exec(ctx, updateUnitFields,
		arg.AlphaTag,
		arg.AlphaTagSource,
		arg.SystemID,
		arg.UnitID,
	)
	return err
}

const upsertUnit = `-- name: UpsertUnit :exec
INSERT INTO units (system_id, unit_id, alpha_tag, first_seen, last_seen, last_event_type, last_event_time, last_event_tgid)
VALUES ($1, $2, $3, $4, $4, $5, $4, $6)
ON CONFLICT (system_id, unit_id) DO UPDATE SET
    alpha_tag       = COALESCE(NULLIF($3, ''), units.alpha_tag),
    first_seen      = LEAST(units.first_seen, $4),
    last_seen       = GREATEST(units.last_seen, $4),
    last_event_type = CASE WHEN $4 >= units.last_event_time THEN $5 ELSE units.last_event_type END,
    last_event_time = GREATEST(units.last_event_time, $4),
    last_event_tgid = CASE WHEN $4 >= units.last_event_time AND $6 > 0 THEN $6 ELSE units.last_event_tgid END
`

type UpsertUnitParams struct {
	SystemID  int
	UnitID    int
	AlphaTag  *string
	EventTime pgtype.Timestamptz
	EventType *string
	Tgid      *int32
}

func (q *Queries) UpsertUnit(ctx context.Context, arg UpsertUnitParams) error {
	_, err := q.db.Exec(ctx, upsertUnit,
		arg.SystemID,
		arg.UnitID,
		arg.AlphaTag,
		arg.EventTime,
		arg.EventType,
		arg.Tgid,
	)
	return err
}
