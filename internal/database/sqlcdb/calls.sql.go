// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: calls.sql

package sqlcdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findCallByTrCallID = `-- name: FindCallByTrCallID :one
SELECT call_id, start_time FROM calls
WHERE tr_call_id = $1
    AND ($2::timestamptz IS NULL OR start_time BETWEEN $2 - interval '30 seconds' AND $2 + interval '30 seconds')
ORDER BY start_time DESC
LIMIT 1
`

type FindCallByTrCallIDParams struct {
	TrCallID *string
	Column2  pgtype.Timestamptz
}

type FindCallByTrCallIDRow struct {
	CallID    int64
	StartTime pgtype.Timestamptz
}

// Uses start_time hint ($2) for partition pruning when available.
// Pass NULL to skip pruning and scan all partitions.
func (q *Queries) FindCallByTrCallID(ctx context.Context, arg FindCallByTrCallIDParams) (FindCallByTrCallIDRow, error) {
	row := q.db.QueryRow(ctx, findCallByTrCallID, arg.TrCallID, arg.Column2)
	var i FindCallByTrCallIDRow
	err := row.Scan(&i.CallID, &i.StartTime)
	return i, err
}

const findCallForAudio = `-- name: FindCallForAudio :one
SELECT call_id, start_time FROM calls
WHERE system_id = $1 AND tgid = $2
    AND start_time BETWEEN $3::timestamptz - interval '5 seconds' AND $3::timestamptz + interval '5 seconds'
ORDER BY ABS(EXTRACT(EPOCH FROM (start_time - $3::timestamptz)))
LIMIT 1
`

type FindCallForAudioParams struct {
	SystemID int
	Tgid     int
	Column3  pgtype.Timestamptz
}

type FindCallForAudioRow struct {
	CallID    int64
	StartTime pgtype.Timestamptz
}

func (q *Queries) FindCallForAudio(ctx context.Context, arg FindCallForAudioParams) (FindCallForAudioRow, error) {
	row := q.db.QueryRow(ctx, findCallForAudio, arg.SystemID, arg.Tgid, arg.Column3)
	var i FindCallForAudioRow
	err := row.Scan(&i.CallID, &i.StartTime)
	return i, err
}

const getCallAudioPath = `-- name: GetCallAudioPath :one
SELECT COALESCE(audio_file_path, '') AS audio_file_path, COALESCE(call_filename, '') AS call_filename
FROM calls WHERE call_id = $1
ORDER BY start_time DESC LIMIT 1
`

type GetCallAudioPathRow struct {
	AudioFilePath string
	CallFilename  string
}

func (q *Queries) GetCallAudioPath(ctx context.Context, callID int64) (GetCallAudioPathRow, error) {
	row := q.db.QueryRow(ctx, getCallAudioPath, callID)
	var i GetCallAudioPathRow
	err := row.Scan(&i.AudioFilePath, &i.CallFilename)
	return i, err
}

const getCallFreqList = `-- name: GetCallFreqList :one
SELECT freq_list FROM calls WHERE call_id = $1 ORDER BY start_time DESC LIMIT 1
`

func (q *Queries) GetCallFreqList(ctx context.Context, callID int64) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCallFreqList, callID)
	var freq_list []byte
	err := row.Scan(&freq_list)
	return freq_list, err
}

const getCallSrcList = `-- name: GetCallSrcList :one
SELECT src_list FROM calls WHERE call_id = $1 ORDER BY start_time DESC LIMIT 1
`

func (q *Queries) GetCallSrcList(ctx context.Context, callID int64) ([]byte, error) {
	row := q.db.QueryRow(ctx, getCallSrcList, callID)
	var src_list []byte
	err := row.Scan(&src_list)
	return src_list, err
}

const insertActiveCallCheckpoint = `-- name: InsertActiveCallCheckpoint :exec
INSERT INTO call_active_checkpoints (instance_id, active_calls, call_count)
VALUES ($1, $2, $3)
`

type InsertActiveCallCheckpointParams struct {
	InstanceID  *string
	ActiveCalls []byte
	CallCount   *int32
}

func (q *Queries) InsertActiveCallCheckpoint(ctx context.Context, arg InsertActiveCallCheckpointParams) error {
	_, err := q.db.Exec(ctx, insertActiveCallCheckpoint, arg.InstanceID, arg.ActiveCalls, arg.CallCount)
	return err
}

const insertCall = `-- name: InsertCall :one
INSERT INTO calls (
    system_id, site_id, tgid, tr_call_id, call_num,
    start_time, stop_time, duration, freq, freq_error,
    signal_db, noise_db, error_count, spike_count,
    audio_type, phase2_tdma, tdma_slot, analog, conventional,
    encrypted, emergency,
    call_state, call_state_type, mon_state, mon_state_type,
    rec_state, rec_state_type, rec_num, src_num,
    patched_tgids,
    src_list, freq_list, unit_ids,
    system_name, site_short_name,
    tg_alpha_tag, tg_description, tg_tag, tg_group,
    incidentdata,
    instance_id
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10,
    $11, $12, $13, $14,
    $15, $16, $17, $18, $19,
    $20, $21,
    $22, $23, $24, $25,
    $26, $27, $28, $29,
    $30,
    $31, $32, $33,
    $34, $35,
    $36, $37, $38, $39,
    $40,
    $41
) RETURNING call_id
`

type InsertCallParams struct {
	SystemID      int
	SiteID        *int32
	Tgid          int
	TrCallID      *string
	CallNum       *int32
	StartTime     pgtype.Timestamptz
	StopTime      pgtype.Timestamptz
	Duration      *float32
	Freq          *int64
	FreqError     *int32
	SignalDb      *float32
	NoiseDb       *float32
	ErrorCount    *int32
	SpikeCount    *int32
	AudioType     *string
	Phase2Tdma    *bool
	TdmaSlot      *int16
	Analog        *bool
	Conventional  *bool
	Encrypted     *bool
	Emergency     *bool
	CallState     *int16
	CallStateType *string
	MonState      *int16
	MonStateType  *string
	RecState      *int16
	RecStateType  *string
	RecNum        *int16
	SrcNum        *int16
	PatchedTgids  []int
	SrcList       []byte
	FreqList      []byte
	UnitIds       []int
	SystemName    *string
	SiteShortName *string
	TgAlphaTag    *string
	TgDescription *string
	TgTag         *string
	TgGroup       *string
	Incidentdata  []byte
	InstanceID    *string
}

func (q *Queries) InsertCall(ctx context.Context, arg InsertCallParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertCall,
		arg.SystemID,
		arg.SiteID,
		arg.Tgid,
		arg.TrCallID,
		arg.CallNum,
		arg.StartTime,
		arg.StopTime,
		arg.Duration,
		arg.Freq,
		arg.FreqError,
		arg.SignalDb,
		arg.NoiseDb,
		arg.ErrorCount,
		arg.SpikeCount,
		arg.AudioType,
		arg.Phase2Tdma,
		arg.TdmaSlot,
		arg.Analog,
		arg.Conventional,
		arg.Encrypted,
		arg.Emergency,
		arg.CallState,
		arg.CallStateType,
		arg.MonState,
		arg.MonStateType,
		arg.RecState,
		arg.RecStateType,
		arg.RecNum,
		arg.SrcNum,
		arg.PatchedTgids,
		arg.SrcList,
		arg.FreqList,
		arg.UnitIds,
		arg.SystemName,
		arg.SiteShortName,
		arg.TgAlphaTag,
		arg.TgDescription,
		arg.TgTag,
		arg.TgGroup,
		arg.Incidentdata,
		arg.InstanceID,
	)
	var call_id int64
	err := row.Scan(&call_id)
	return call_id, err
}

type InsertCallFrequenciesParams struct {
	CallID        int64
	CallStartTime pgtype.Timestamptz
	Freq          int64
	Time          pgtype.Timestamptz
	Pos           *float32
	Len           *float32
	ErrorCount    *int32
	SpikeCount    *int32
}

type InsertCallTransmissionsParams struct {
	CallID        int64
	CallStartTime pgtype.Timestamptz
	Src           int
	Time          pgtype.Timestamptz
	Pos           *float32
	Duration      *float32
	Emergency     *int16
	SignalSystem  *string
	Tag           *string
}

const purgeOrphanCallGroups = `-- name: PurgeOrphanCallGroups :execrows
DELETE FROM call_groups cg
WHERE NOT EXISTS (SELECT 1 FROM calls c WHERE c.call_group_id = cg.id)
`

func (q *Queries) PurgeOrphanCallGroups(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, purgeOrphanCallGroups)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const purgeStaleCalls = `-- name: PurgeStaleCalls :execrows
DELETE FROM calls
WHERE rec_state_type = 'RECORDING'
    AND audio_file_path IS NULL
    AND (stop_time IS NULL OR duration IS NULL OR duration = 0)
    AND start_time < $1
`

func (q *Queries) PurgeStaleCalls(ctx context.Context, startTime pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, purgeStaleCalls, startTime)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const setCallGroupID = `-- name: SetCallGroupID :exec
UPDATE calls SET call_group_id = $3
WHERE call_id = $1 AND start_time = $2
`

type SetCallGroupIDParams struct {
	CallID      int64
	StartTime   pgtype.Timestamptz
	CallGroupID *int32
}

func (q *Queries) SetCallGroupID(ctx context.Context, arg SetCallGroupIDParams) error {
	_, err := q.db.Exec(ctx, setCallGroupID, arg.CallID, arg.StartTime, arg.CallGroupID)
	return err
}

const setCallGroupPrimary = `-- name: SetCallGroupPrimary :exec
UPDATE call_groups SET primary_call_id = $2
WHERE id = $1 AND primary_call_id IS NULL
`

type SetCallGroupPrimaryParams struct {
	ID            int
	PrimaryCallID *int64
}

func (q *Queries) SetCallGroupPrimary(ctx context.Context, arg SetCallGroupPrimaryParams) error {
	_, err := q.db.Exec(ctx, setCallGroupPrimary, arg.ID, arg.PrimaryCallID)
	return err
}

const updateCallAudio = `-- name: UpdateCallAudio :exec
UPDATE calls SET
    audio_file_path = $3,
    audio_file_size = $4
WHERE call_id = $1 AND start_time = $2
`

type UpdateCallAudioParams struct {
	CallID        int64
	StartTime     pgtype.Timestamptz
	AudioFilePath *string
	AudioFileSize *int32
}

func (q *Queries) UpdateCallAudio(ctx context.Context, arg UpdateCallAudioParams) error {
	_, err := q.db.Exec(ctx, updateCallAudio,
		arg.CallID,
		arg.StartTime,
		arg.AudioFilePath,
		arg.AudioFileSize,
	)
	return err
}

const updateCallElapsed = `-- name: UpdateCallElapsed :exec
UPDATE calls SET
    stop_time = COALESCE($3, stop_time),
    duration = COALESCE($4, duration),
    updated_at = now()
WHERE call_id = $1 AND start_time = $2
    AND (duration IS NULL OR duration = 0)
`

type UpdateCallElapsedParams struct {
	CallID    int64
	StartTime pgtype.Timestamptz
	StopTime  pgtype.Timestamptz
	Duration  *float32
}

func (q *Queries) UpdateCallElapsed(ctx context.Context, arg UpdateCallElapsedParams) error {
	_, err := q.db.Exec(ctx, updateCallElapsed,
		arg.CallID,
		arg.StartTime,
		arg.StopTime,
		arg.Duration,
	)
	return err
}

const updateCallEnd = `-- name: UpdateCallEnd :exec
UPDATE calls SET
    stop_time = $3,
    duration = $4,
    freq = $5,
    freq_error = $6,
    signal_db = $7,
    noise_db = $8,
    error_count = $9,
    spike_count = $10,
    rec_state = $11,
    rec_state_type = $12,
    call_state = $13,
    call_state_type = $14,
    call_filename = $15,
    retry_attempt = $16,
    process_call_time = $17
WHERE call_id = $1 AND start_time = $2
`

type UpdateCallEndParams struct {
	CallID          int64
	StartTime       pgtype.Timestamptz
	StopTime        pgtype.Timestamptz
	Duration        *float32
	Freq            *int64
	FreqError       *int32
	SignalDb        *float32
	NoiseDb         *float32
	ErrorCount      *int32
	SpikeCount      *int32
	RecState        *int16
	RecStateType    *string
	CallState       *int16
	CallStateType   *string
	CallFilename    *string
	RetryAttempt    *int16
	ProcessCallTime *float32
}

func (q *Queries) UpdateCallEnd(ctx context.Context, arg UpdateCallEndParams) error {
	_, err := q.db.Exec(ctx, updateCallEnd,
		arg.CallID,
		arg.StartTime,
		arg.StopTime,
		arg.Duration,
		arg.Freq,
		arg.FreqError,
		arg.SignalDb,
		arg.NoiseDb,
		arg.ErrorCount,
		arg.SpikeCount,
		arg.RecState,
		arg.RecStateType,
		arg.CallState,
		arg.CallStateType,
		arg.CallFilename,
		arg.RetryAttempt,
		arg.ProcessCallTime,
	)
	return err
}

const updateCallFilename = `-- name: UpdateCallFilename :exec
UPDATE calls SET call_filename = $3
WHERE call_id = $1 AND start_time = $2
`

type UpdateCallFilenameParams struct {
	CallID       int64
	StartTime    pgtype.Timestamptz
	CallFilename *string
}

func (q *Queries) UpdateCallFilename(ctx context.Context, arg UpdateCallFilenameParams) error {
	_, err := q.db.Exec(ctx, updateCallFilename, arg.CallID, arg.StartTime, arg.CallFilename)
	return err
}

const updateCallSrcFreq = `-- name: UpdateCallSrcFreq :exec
UPDATE calls SET
    src_list = $3,
    freq_list = $4,
    unit_ids = $5
WHERE call_id = $1 AND start_time = $2
`

type UpdateCallSrcFreqParams struct {
	CallID    int64
	StartTime pgtype.Timestamptz
	SrcList   []byte
	FreqList  []byte
	UnitIds   []int
}

func (q *Queries) UpdateCallSrcFreq(ctx context.Context, arg UpdateCallSrcFreqParams) error {
	_, err := q.db.Exec(ctx, updateCallSrcFreq,
		arg.CallID,
		arg.StartTime,
		arg.SrcList,
		arg.FreqList,
		arg.UnitIds,
	)
	return err
}

const updateCallStartFields = `-- name: UpdateCallStartFields :exec
UPDATE calls SET
    tr_call_id = $3,
    call_num = $4,
    instance_id = $5,
    call_state = $6,
    call_state_type = $7,
    mon_state = $8,
    mon_state_type = $9,
    rec_state = $10,
    rec_state_type = $11
WHERE call_id = $1 AND start_time = $2
`

type UpdateCallStartFieldsParams struct {
	CallID        int64
	StartTime     pgtype.Timestamptz
	TrCallID      *string
	CallNum       *int32
	InstanceID    *string
	CallState     *int16
	CallStateType *string
	MonState      *int16
	MonStateType  *string
	RecState      *int16
	RecStateType  *string
}

func (q *Queries) UpdateCallStartFields(ctx context.Context, arg UpdateCallStartFieldsParams) error {
	_, err := q.db.Exec(ctx, updateCallStartFields,
		arg.CallID,
		arg.StartTime,
		arg.TrCallID,
		arg.CallNum,
		arg.InstanceID,
		arg.CallState,
		arg.CallStateType,
		arg.MonState,
		arg.MonStateType,
		arg.RecState,
		arg.RecStateType,
	)
	return err
}

const upsertCallGroup = `-- name: UpsertCallGroup :one
INSERT INTO call_groups (system_id, tgid, start_time, tg_alpha_tag, tg_description, tg_tag, tg_group)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (system_id, tgid, start_time) DO UPDATE SET
    tg_alpha_tag   = COALESCE(NULLIF($4, ''), call_groups.tg_alpha_tag),
    tg_description = COALESCE(NULLIF($5, ''), call_groups.tg_description)
RETURNING id
`

type UpsertCallGroupParams struct {
	SystemID      int
	Tgid          int
	StartTime     pgtype.Timestamptz
	TgAlphaTag    *string
	TgDescription *string
	TgTag         *string
	TgGroup       *string
}

func (q *Queries) UpsertCallGroup(ctx context.Context, arg UpsertCallGroupParams) (int, error) {
	row := q.db.QueryRow(ctx, upsertCallGroup,
		arg.SystemID,
		arg.Tgid,
		arg.StartTime,
		arg.TgAlphaTag,
		arg.TgDescription,
		arg.TgTag,
		arg.TgGroup,
	)
	var id int
	err := row.Scan(&id)
	return id, err
}
