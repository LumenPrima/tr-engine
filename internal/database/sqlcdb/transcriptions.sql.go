// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transcriptions.sql

package sqlcdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearPrimaryTranscription = `-- name: ClearPrimaryTranscription :exec
UPDATE transcriptions SET is_primary = false
WHERE call_id = $1 AND call_start_time = $2 AND is_primary = true
`

type ClearPrimaryTranscriptionParams struct {
	CallID        int64
	CallStartTime pgtype.Timestamptz
}

func (q *Queries) ClearPrimaryTranscription(ctx context.Context, arg ClearPrimaryTranscriptionParams) error {
	_, err := q.db.Exec(ctx, clearPrimaryTranscription, arg.CallID, arg.CallStartTime)
	return err
}

const getCallForTranscription = `-- name: GetCallForTranscription :one
SELECT call_id, start_time, system_id, tgid, duration,
    COALESCE(audio_file_path, '') AS audio_file_path,
    COALESCE(call_filename, '') AS call_filename,
    src_list, encrypted, has_transcription,
    COALESCE(tg_alpha_tag, '') AS tg_alpha_tag,
    COALESCE(tg_description, '') AS tg_description,
    COALESCE(tg_tag, '') AS tg_tag,
    COALESCE(tg_group, '') AS tg_group
FROM calls
WHERE call_id = $1
ORDER BY start_time DESC
LIMIT 1
`

type GetCallForTranscriptionRow struct {
	CallID           int64
	StartTime        pgtype.Timestamptz
	SystemID         int
	Tgid             int
	Duration         *float32
	AudioFilePath    string
	CallFilename     string
	SrcList          []byte
	Encrypted        *bool
	HasTranscription bool
	TgAlphaTag       string
	TgDescription    string
	TgTag            string
	TgGroup          string
}

func (q *Queries) GetCallForTranscription(ctx context.Context, callID int64) (GetCallForTranscriptionRow, error) {
	row := q.db.QueryRow(ctx, getCallForTranscription, callID)
	var i GetCallForTranscriptionRow
	err := row.Scan(
		&i.CallID,
		&i.StartTime,
		&i.SystemID,
		&i.Tgid,
		&i.Duration,
		&i.AudioFilePath,
		&i.CallFilename,
		&i.SrcList,
		&i.Encrypted,
		&i.HasTranscription,
		&i.TgAlphaTag,
		&i.TgDescription,
		&i.TgTag,
		&i.TgGroup,
	)
	return i, err
}

const getPrimaryTranscription = `-- name: GetPrimaryTranscription :one
SELECT id, call_id, text, source, is_primary,
    confidence, language, model, provider,
    word_count, duration_ms, words, created_at
FROM transcriptions
WHERE call_id = $1 AND is_primary = true
ORDER BY created_at DESC
LIMIT 1
`

type GetPrimaryTranscriptionRow struct {
	ID         int
	CallID     int64
	Text       *string
	Source     string
	IsPrimary  bool
	Confidence *float32
	Language   *string
	Model      *string
	Provider   *string
	WordCount  *int32
	DurationMs *int32
	Words      []byte
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) GetPrimaryTranscription(ctx context.Context, callID int64) (GetPrimaryTranscriptionRow, error) {
	row := q.db.QueryRow(ctx, getPrimaryTranscription, callID)
	var i GetPrimaryTranscriptionRow
	err := row.Scan(
		&i.ID,
		&i.CallID,
		&i.Text,
		&i.Source,
		&i.IsPrimary,
		&i.Confidence,
		&i.Language,
		&i.Model,
		&i.Provider,
		&i.WordCount,
		&i.DurationMs,
		&i.Words,
		&i.CreatedAt,
	)
	return i, err
}

const insertTranscriptionRow = `-- name: InsertTranscriptionRow :one
INSERT INTO transcriptions (
    call_id, call_start_time, text, source, is_primary,
    confidence, language, model, provider,
    word_count, duration_ms, words
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id
`

type InsertTranscriptionRowParams struct {
	CallID        int64
	CallStartTime pgtype.Timestamptz
	Text          *string
	Source        string
	IsPrimary     bool
	Confidence    *float32
	Language      *string
	Model         *string
	Provider      *string
	WordCount     *int32
	DurationMs    *int32
	Words         []byte
}

func (q *Queries) InsertTranscriptionRow(ctx context.Context, arg InsertTranscriptionRowParams) (int, error) {
	row := q.db.QueryRow(ctx, insertTranscriptionRow,
		arg.CallID,
		arg.CallStartTime,
		arg.Text,
		arg.Source,
		arg.IsPrimary,
		arg.Confidence,
		arg.Language,
		arg.Model,
		arg.Provider,
		arg.WordCount,
		arg.DurationMs,
		arg.Words,
	)
	var id int
	err := row.Scan(&id)
	return id, err
}

const listTranscriptionsByCall = `-- name: ListTranscriptionsByCall :many
SELECT id, call_id, text, source, is_primary,
    confidence, language, model, provider,
    word_count, duration_ms, words, created_at
FROM transcriptions
WHERE call_id = $1
ORDER BY created_at DESC
`

type ListTranscriptionsByCallRow struct {
	ID         int
	CallID     int64
	Text       *string
	Source     string
	IsPrimary  bool
	Confidence *float32
	Language   *string
	Model      *string
	Provider   *string
	WordCount  *int32
	DurationMs *int32
	Words      []byte
	CreatedAt  pgtype.Timestamptz
}

func (q *Queries) ListTranscriptionsByCall(ctx context.Context, callID int64) ([]ListTranscriptionsByCallRow, error) {
	rows, err := q.db.Query(ctx, listTranscriptionsByCall, callID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTranscriptionsByCallRow{}
	for rows.Next() {
		var i ListTranscriptionsByCallRow
		if err := rows.Scan(
			&i.ID,
			&i.CallID,
			&i.Text,
			&i.Source,
			&i.IsPrimary,
			&i.Confidence,
			&i.Language,
			&i.Model,
			&i.Provider,
			&i.WordCount,
			&i.DurationMs,
			&i.Words,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCallGroupTranscriptionDenorm = `-- name: UpdateCallGroupTranscriptionDenorm :exec
UPDATE call_groups SET
    transcription_text = $3,
    transcription_status = $4
WHERE id = (
    SELECT c.call_group_id FROM calls c
    WHERE c.call_id = $1 AND c.start_time = $2 AND c.call_group_id IS NOT NULL
)
`

type UpdateCallGroupTranscriptionDenormParams struct {
	CallID              int64
	StartTime           pgtype.Timestamptz
	TranscriptionText   *string
	TranscriptionStatus *string
}

func (q *Queries) UpdateCallGroupTranscriptionDenorm(ctx context.Context, arg UpdateCallGroupTranscriptionDenormParams) error {
	_, err := q.db.Exec(ctx, updateCallGroupTranscriptionDenorm,
		arg.CallID,
		arg.StartTime,
		arg.TranscriptionText,
		arg.TranscriptionStatus,
	)
	return err
}

const updateCallGroupTranscriptionStatus = `-- name: UpdateCallGroupTranscriptionStatus :exec
UPDATE call_groups SET transcription_status = $3
WHERE id = (
    SELECT c.call_group_id FROM calls c
    WHERE c.call_id = $1 AND c.start_time = $2 AND c.call_group_id IS NOT NULL
)
`

type UpdateCallGroupTranscriptionStatusParams struct {
	CallID              int64
	StartTime           pgtype.Timestamptz
	TranscriptionStatus *string
}

func (q *Queries) UpdateCallGroupTranscriptionStatus(ctx context.Context, arg UpdateCallGroupTranscriptionStatusParams) error {
	_, err := q.db.Exec(ctx, updateCallGroupTranscriptionStatus, arg.CallID, arg.StartTime, arg.TranscriptionStatus)
	return err
}

const updateCallTranscriptionDenorm = `-- name: UpdateCallTranscriptionDenorm :exec
UPDATE calls SET
    has_transcription = true,
    transcription_status = $3,
    transcription_text = $4,
    transcription_word_count = $5
WHERE call_id = $1 AND start_time = $2
`

type UpdateCallTranscriptionDenormParams struct {
	CallID                 int64
	StartTime              pgtype.Timestamptz
	TranscriptionStatus    string
	TranscriptionText      *string
	TranscriptionWordCount *int32
}

func (q *Queries) UpdateCallTranscriptionDenorm(ctx context.Context, arg UpdateCallTranscriptionDenormParams) error {
	_, err := q.db.Exec(ctx, updateCallTranscriptionDenorm,
		arg.CallID,
		arg.StartTime,
		arg.TranscriptionStatus,
		arg.TranscriptionText,
		arg.TranscriptionWordCount,
	)
	return err
}

const updateCallTranscriptionStatus = `-- name: UpdateCallTranscriptionStatus :exec
UPDATE calls SET transcription_status = $3
WHERE call_id = $1 AND start_time = $2
`

type UpdateCallTranscriptionStatusParams struct {
	CallID              int64
	StartTime           pgtype.Timestamptz
	TranscriptionStatus string
}

func (q *Queries) UpdateCallTranscriptionStatus(ctx context.Context, arg UpdateCallTranscriptionStatusParams) error {
	_, err := q.db.Exec(ctx, updateCallTranscriptionStatus, arg.CallID, arg.StartTime, arg.TranscriptionStatus)
	return err
}
