<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>tr-engine IRC</title>
<meta name="card-title" content="IRC Radio">
<meta name="card-description" content="IRC-style live radio monitor with channels, nicks, and audio playback">
<meta name="card-order" content="0">
<script src="theme-config.js"></script>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Iosevka:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

html, body { height: 100%; overflow: hidden; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--font-mono), 'Courier New', monospace;
  font-size: 16px;
  line-height: 1.45;
  display: flex;
  flex-direction: column;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    linear-gradient(var(--border) 1px, transparent 1px),
    linear-gradient(90deg, var(--border) 1px, transparent 1px);
  background-size: 60px 60px;
  opacity: 0.04;
  pointer-events: none;
  z-index: 0;
}
body::after {
  content: '';
  position: fixed;
  inset: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.03) 2px,
    rgba(0,0,0,0.03) 4px
  );
  pointer-events: none;
  z-index: 9998;
}
.vignette-overlay {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9997;
  background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.3) 100%);
}

/* â”€â”€ Top bar â”€â”€ */
.titlebar {
  height: 28px;
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  font-size: 14px;
  color: var(--text-mid);
  gap: 8px;
  flex-shrink: 0;
  user-select: none;
}
.titlebar .server { color: var(--cyan); font-weight: 500; }
.titlebar .topic { color: var(--text-muted); margin-left: 8px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.titlebar .lag { color: var(--warning); margin-left: auto; }

/* â”€â”€ Main layout â”€â”€ */
.main { display: flex; flex: 1; overflow: hidden; }

/* â”€â”€ Channel tree (left panel) â”€â”€ */
.channel-tree {
  width: 240px;
  min-width: 240px;
  background: var(--bg-surface);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  user-select: none;
}
.tree-header-row {
  padding: 6px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border);
}
.tree-header-text {
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text-muted);
}
.read-all-btn {
  background: none;
  border: 1px solid var(--border-hover);
  color: var(--text-mid);
  font-family: inherit;
  font-size: 12px;
  padding: 1px 6px;
  border-radius: 3px;
  cursor: pointer;
  transition: color 0.15s, border-color 0.15s;
}
.read-all-btn:hover { color: var(--cyan); border-color: var(--cyan); }
.tree-search {
  padding: 4px 8px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 4px;
  flex-shrink: 0;
}
.tree-search-input {
  flex: 1;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-family: inherit;
  font-size: 13px;
  padding: 3px 6px;
  outline: none;
}
.tree-search-input:focus { border-color: var(--cyan); }
.tree-search-input::placeholder { color: var(--text-faint); }
.tree-search-clear {
  cursor: pointer;
  color: var(--text-muted);
  font-size: 14px;
  visibility: hidden;
  user-select: none;
}
.tree-search-clear.visible { visibility: visible; }
.tree-more {
  padding: 2px 12px 2px 20px;
  font-size: 13px;
  font-style: italic;
  color: var(--text-muted);
  cursor: pointer;
  transition: color 0.15s;
}
.tree-more:hover { color: var(--text-mid); }
.tree-scroll {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}
.tree-scroll::-webkit-scrollbar { width: 6px; }
.tree-scroll::-webkit-scrollbar-track { background: transparent; }
.tree-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.tree-section { padding: 4px 0; }
.tree-section-label {
  padding: 3px 12px;
  font-size: 13px;
  color: var(--text-muted);
  letter-spacing: 0.06em;
  cursor: pointer;
}
.tree-section-label .nb { white-space: nowrap; }
.tree-section-label:hover { color: var(--text-mid); }
.tree-section-label::before { content: 'â–¾ '; font-size: 11px; }
.tree-section-label.collapsed::before { content: 'â–¸ '; }

.channel-item {
  padding: 2px 12px 2px 20px;
  cursor: pointer;
  color: var(--text-mid);
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
  overflow: hidden;
}
.channel-item:hover { background: var(--bg-elevated); color: var(--text); }
.channel-item.active { color: var(--text); background: var(--bg-elevated); font-weight: 500; }
.channel-item.has-activity { color: var(--orange); }
.channel-item .chan-prefix { color: var(--text-muted); }
.channel-item .chan-label { overflow: hidden; text-overflow: ellipsis; }
.channel-item .unread {
  margin-left: auto; font-size: 12px; color: var(--bg);
  background: var(--orange); border-radius: 3px;
  padding: 0 4px; min-width: 14px; text-align: center; font-weight: 600;
  flex-shrink: 0;
}
.channel-icons {
  margin-left: auto;
  display: flex;
  align-items: center;
  flex-shrink: 0;
}
.fav-star {
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.15s;
  color: var(--text-muted);
  font-size: 12px;
  padding: 0 2px;
  flex-shrink: 0;
}
.channel-item:hover .fav-star,
.fav-star.active { opacity: 1; }
.fav-star.active { color: var(--warning); }
.group-unread {
  background: var(--orange);
  color: var(--bg);
  font-size: 10px;
  font-weight: 600;
  padding: 0 5px;
  border-radius: 8px;
  margin-left: 6px;
  min-width: 16px;
  text-align: center;
  display: inline-block;
  line-height: 16px;
}
.scan-icon {
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.15s;
  color: var(--text-muted);
  font-size: 11px;
  flex-shrink: 0;
}
.channel-item:hover .scan-icon,
.scan-icon.active { opacity: 1; }
.scan-icon.active { color: var(--green); }

.scanner-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-family: inherit;
  font-size: 12px;
  padding: 0 6px;
  cursor: pointer;
  border-radius: 3px;
  margin-left: 4px;
}
.scanner-btn.active {
  color: var(--green);
  border-color: var(--green);
}
.scanner-queue-info {
  color: var(--text-muted);
  font-size: 12px;
  margin-left: 4px;
}

.tree-status {
  padding: 8px 12px;
  border-top: 1px solid var(--border);
  font-size: 13px;
  color: var(--text-muted);
  flex-shrink: 0;
}
.tree-status .dot {
  display: inline-block; width: 6px; height: 6px;
  border-radius: 50%; margin-right: 4px; vertical-align: middle;
}
.tree-status .dot.connected { background: var(--success); }
.tree-status .dot.disconnected { background: var(--danger); }
.tree-status .dot.connecting { background: var(--warning); animation: blink 1s infinite; }
@keyframes blink { 50% { opacity: 0.3; } }

/* â”€â”€ Chat area â”€â”€ */
.chat-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0; }

.channel-bar {
  height: 32px;
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 14px;
  gap: 10px;
  flex-shrink: 0;
}
.channel-bar .chan-name { font-weight: 600; font-size: 16px; color: var(--text); }
.channel-bar .chan-topic { font-size: 14px; color: var(--text-mid); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
.channel-bar .chan-mode { font-size: 13px; color: var(--text-muted); }
.channel-bar .chan-count { font-size: 13px; color: var(--text-mid); margin-left: auto; white-space: nowrap; }

/* â”€â”€ Messages â”€â”€ */
.messages {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 4px 0;
}
.messages::-webkit-scrollbar { width: 8px; }
.messages::-webkit-scrollbar-track { background: transparent; }
.messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
.messages::-webkit-scrollbar-thumb:hover { background: var(--border-hover); }

.msg {
  padding: 1px 14px;
  display: flex;
  gap: 0;
  min-height: 19px;
  align-items: baseline;
}
.msg:hover { background: var(--bg-elevated); }
.msg .ts { color: var(--text-faint); font-size: 14px; min-width: 82px; flex-shrink: 0; user-select: none; }
.date-separator {
  text-align: center;
  font-size: 13px;
  color: var(--text-muted);
  padding: 6px 14px 4px;
  position: relative;
}
.date-separator::before, .date-separator::after {
  content: '';
  position: absolute;
  top: 50%;
  height: 1px;
  background: var(--border);
  width: calc(50% - 80px);
}
.date-separator::before { left: 14px; }
.date-separator::after { right: 14px; }
.msg .nick {
  font-weight: 500; min-width: 130px; max-width: 130px; text-align: right;
  padding-right: 8px; flex-shrink: 0;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.msg .nick::before { content: '<'; color: var(--text-muted); }
.msg .nick::after { content: '>'; color: var(--text-muted); }
.msg .body { flex: 1; word-break: break-word; min-width: 0; }

.msg.system .nick { min-width: 0; max-width: none; padding-right: 0; }
.msg.system .nick::before, .msg.system .nick::after { display: none; }
.msg.system .prefix { color: var(--text-muted); margin-right: 0; }
.msg.system .body { font-size: 15px; }

.msg.join .body { color: var(--success); }
.msg.part .body, .msg.quit .body { color: var(--danger); }
.msg.mode .body { color: var(--info); }
.msg.action .body { color: var(--magenta); font-style: italic; }
.msg.notice .body { color: var(--info); }
.msg.topic .body { color: var(--info); }

.msg.emergency { background: color-mix(in srgb, var(--danger) 8%, transparent); }
.msg.emergency .body { color: var(--danger); font-weight: 600; }
.msg.emergency .nick { color: var(--danger) !important; }

.msg.encrypted { background: color-mix(in srgb, var(--warning) 6%, transparent); }
.msg.encrypted .body { color: var(--warning); font-style: italic; }

/* â”€â”€ Call grouping â€” visual bracket for multi-transmission calls â”€â”€ */
.msg.call-group-first,
.msg.call-group-mid,
.msg.call-group-last { position: relative; padding-top: 0; padding-bottom: 0; min-height: 18px; }
.msg.call-group-first::before,
.msg.call-group-mid::before,
.msg.call-group-last::before {
  content: ''; position: absolute; left: 70px; top: 0; bottom: 0;
  border-left: 2px solid var(--border-hover);
}
.msg.call-group-first::before { top: 50%; }
.msg.call-group-last::before { bottom: 50%; }
.msg.call-group-mid .ts, .msg.call-group-last .ts { visibility: hidden; }

/* â”€â”€ Typing bar â”€â”€ */
.typing-bar {
  min-height: 20px;
  padding: 2px 14px;
  font-size: 14px;
  color: var(--text-muted);
  border-top: 1px solid var(--border);
  background: var(--bg);
  flex-shrink: 0;
}
.typing-bar .typing-nick { color: var(--cyan); }

/* â”€â”€ Audio player bar â”€â”€ */
.player-bar {
  display: none;
  border-top: 1px solid var(--border);
  background: var(--bg-surface);
  flex-shrink: 0;
  padding: 4px 14px;
}
.player-bar.active { display: block; }
.player-inner {
  display: flex;
  align-items: center;
  gap: 10px;
}
.player-btn {
  background: none;
  border: 1px solid var(--border-hover);
  color: var(--cyan);
  font-size: 14px;
  width: 26px;
  height: 22px;
  border-radius: 3px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-family: inherit;
  transition: border-color 0.15s, color 0.15s;
}
.player-btn:hover { border-color: var(--cyan); color: var(--text); }
.player-btn.player-skip { color: var(--text-mid); font-size: 12px; width: 22px; }
.player-btn.player-skip:hover { border-color: var(--green); color: var(--green); }
.player-btn.player-close { color: var(--text-mid); font-size: 13px; width: 22px; }
.player-btn.player-close:hover { color: var(--danger); border-color: var(--danger); }
.player-info {
  display: flex;
  gap: 8px;
  align-items: center;
  font-size: 14px;
  min-width: 0;
  flex-shrink: 0;
}
.player-nick { color: var(--cyan); font-weight: 500; }
.player-chan { color: var(--text-muted); }
.player-time { color: var(--text-mid); font-size: 13px; font-variant-numeric: tabular-nums; }
.player-progress {
  flex: 1;
  height: 4px;
  background: var(--border);
  border-radius: 2px;
  cursor: pointer;
  position: relative;
  min-width: 60px;
}
.player-progress-fill {
  height: 100%;
  background: var(--cyan);
  border-radius: 2px;
  width: 0%;
  transition: width 0.1s linear;
}
.player-progress:hover .player-progress-fill { background: var(--text); }

/* â”€â”€ Voice message links â”€â”€ */
.voice-play { color: var(--cyan); font-size: 15px; margin-right: 2px; cursor: pointer; }
.voice-dur { color: var(--text); }
.voice-listen {
  color: var(--text-mid);
  cursor: pointer;
  text-decoration: none;
  border-bottom: 1px dotted var(--text-muted);
  margin-left: 4px;
  transition: color 0.15s;
}
.voice-listen:hover { color: var(--cyan); border-bottom-color: var(--cyan); }
.voice-text { color: var(--text); }
.voice-controls { color: var(--text-muted); font-size: 14px; margin-left: 6px; white-space: nowrap; }
.voice-controls .voice-play { font-size: 13px; }
.voice-controls .voice-listen { margin-left: 2px; }
.msg.now-playing { background: color-mix(in srgb, var(--cyan) 4%, transparent); }
.msg.now-playing .voice-listen { color: var(--cyan); border-bottom-color: var(--cyan); }

/* â”€â”€ Input â”€â”€ */
.input-area {
  display: flex;
  align-items: center;
  border-top: 1px solid var(--border);
  background: var(--bg);
  flex-shrink: 0;
}
.input-prompt {
  padding: 0 4px 0 14px;
  color: var(--text-mid);
  font-size: 15px;
  user-select: none;
  white-space: nowrap;
}
.input-field {
  flex: 1;
  background: none;
  border: none;
  outline: none;
  color: var(--text);
  font-family: inherit;
  font-size: 16px;
  padding: 8px 8px;
  caret-color: var(--cyan);
}
.input-field::placeholder { color: var(--text-muted); }

/* â”€â”€ Nicklist â”€â”€ */
.nicklist {
  width: 164px;
  min-width: 164px;
  background: var(--bg-surface);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  user-select: none;
}
.nicklist-header {
  padding: 8px 10px;
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
  border-bottom: 1px solid var(--border);
}
.nicklist-section-label {
  padding: 4px 10px 2px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
}
.nicklist-entries {
  overflow-y: auto;
  flex: 1;
}
.nicklist-entries::-webkit-scrollbar { width: 6px; }
.nicklist-entries::-webkit-scrollbar-track { background: transparent; }
.nicklist-entries::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.nick-item {
  padding: 1px 10px;
  font-size: 14px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: default;
}
.nick-item:hover { background: var(--bg-elevated); }
.nick-item .nick-prefix { color: var(--text-muted); font-size: 13px; margin-right: 2px; }
.nick-item.op { color: var(--cyan); }
.nick-item.voice { color: var(--green); }
.nick-item.regular { color: var(--text-mid); }
.nick-item.offline { opacity: 0.35; }
.nick-item.talked::after { content: 'â—'; color: var(--green); font-size: 10px; margin-left: 4px; vertical-align: middle; }

/* â”€â”€ Nick tooltip â”€â”€ */
.nick-tooltip {
  display: none; position: fixed; z-index: 100;
  background: var(--bg-elevated); border: 1px solid var(--border-hover); border-radius: 4px;
  padding: 6px 10px; font-size: 14px; line-height: 1.5;
  color: var(--text-mid); pointer-events: none;
  max-width: 260px; white-space: nowrap;
  box-shadow: var(--shadow-panel);
}
.nick-tooltip .tt-nick { color: var(--cyan); font-weight: 600; }
.nick-tooltip .tt-label { color: var(--text-muted); }
.nick-tooltip .tt-online { color: var(--green); }
.nick-tooltip .tt-offline { color: var(--text-faint); }
.msg .nick { cursor: default; }
.nick-item { cursor: default; }

/* â”€â”€ Status bar â”€â”€ */
.statusbar {
  height: 22px;
  background: var(--bg-surface);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  font-size: 13px;
  color: var(--text-muted);
  gap: 16px;
  flex-shrink: 0;
  user-select: none;
}
.statusbar .sep { color: var(--border-hover); }
.statusbar .status-highlight { color: var(--orange); }
.statusbar .status-ok { color: var(--success); }
.statusbar .status-err { color: var(--danger); }
.statusbar .nerd-btn {
  background: none;
  border: 1px solid var(--border-hover);
  color: var(--text-muted);
  font-family: inherit;
  font-size: 12px;
  padding: 0 4px;
  border-radius: 2px;
  cursor: pointer;
  line-height: 16px;
  margin-left: auto;
  transition: color 0.15s, border-color 0.15s;
}
.statusbar .nerd-btn:hover { color: var(--cyan); border-color: var(--cyan); }
html.nerd .statusbar .nerd-btn { color: var(--magenta); border-color: var(--magenta); }

/* â”€â”€ Hipster nerd cool mode â€” tiny text â”€â”€ */
html.nerd body { font-size: 13px; }
html.nerd .titlebar { font-size: 11px; }
html.nerd .tree-header-text { font-size: 10px; }
html.nerd .read-all-btn { font-size: 9px; }
html.nerd .tree-more { font-size: 10px; }
html.nerd .tree-section-label { font-size: 10px; }
html.nerd .tree-section-label::before { font-size: 8px; }
html.nerd .channel-item { font-size: 11px; }
html.nerd .channel-item .unread { font-size: 9px; }
html.nerd .tree-status { font-size: 10px; }
html.nerd .channel-bar .chan-name { font-size: 13px; }
html.nerd .channel-bar .chan-topic { font-size: 11px; }
html.nerd .channel-bar .chan-mode { font-size: 10px; }
html.nerd .channel-bar .chan-count { font-size: 10px; }
html.nerd .msg .ts { font-size: 11px; }
html.nerd .date-separator { font-size: 10px; }
html.nerd .msg.system .body { font-size: 12px; }
html.nerd .typing-bar { font-size: 11px; }
html.nerd .player-btn { font-size: 11px; }
html.nerd .player-btn.player-close { font-size: 10px; }
html.nerd .player-info { font-size: 11px; }
html.nerd .player-time { font-size: 10px; }
html.nerd .voice-play { font-size: 12px; }
html.nerd .input-prompt { font-size: 12px; }
html.nerd .input-field { font-size: 13px; }
html.nerd .nicklist-header { font-size: 10px; }
html.nerd .nicklist-section-label { font-size: 9px; }
html.nerd .nick-item { font-size: 11px; }
html.nerd .nick-item .nick-prefix { font-size: 10px; }
html.nerd .nick-item.talked::after { font-size: 7px; }
html.nerd .nick-tooltip { font-size: 11px; }
html.nerd .statusbar { font-size: 10px; }
html.nerd .statusbar .nerd-btn { font-size: 9px; }

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
/* MOBILE RESPONSIVE â€” below 768px                               */
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

@media (max-width: 768px) {
  /* Hide CRT effects on mobile for performance */
  body::before, body::after, .vignette-overlay { display: none; }

  /* Titlebar becomes mobile nav */
  .titlebar {
    height: 44px;
    padding: 0 8px;
    justify-content: space-between;
  }
  .titlebar .topic { display: none; }

  /* Hamburger button */
  .mobile-hamburger {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    font-size: 20px;
    cursor: pointer;
    color: var(--text);
    border: none;
    background: none;
  }

  /* Channel tree becomes slide-out drawer */
  .channel-tree {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 280px;
    z-index: 1000;
    transform: translateX(-100%);
    transition: transform 0.25s ease;
    box-shadow: none;
  }
  .channel-tree.open {
    transform: translateX(0);
    box-shadow: 4px 0 20px rgba(0,0,0,0.3);
  }

  /* Nicklist becomes slide-out drawer from right */
  .nicklist {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    width: 240px;
    z-index: 1000;
    transform: translateX(100%);
    transition: transform 0.25s ease;
    box-shadow: none;
  }
  .nicklist.open {
    transform: translateX(0);
    box-shadow: -4px 0 20px rgba(0,0,0,0.3);
  }

  /* Drawer backdrop */
  .drawer-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 999;
  }
  .drawer-backdrop.visible { display: block; }

  /* Messages take full width */
  .chat-area { flex: 1; min-width: 0; }
  .messages { font-size: 14px; }

  /* Channel bar simplification */
  .channel-bar {
    height: 36px;
    font-size: 13px;
  }

  /* Input area */
  .input-area { font-size: 14px; }
  .input-field { font-size: 14px; }

  /* Status bar */
  .statusbar { font-size: 11px; padding: 0 6px; }

  /* Nick width smaller on mobile */
  .nick { max-width: 80px !important; }

  /* Larger touch targets for audio play buttons */
  .voice-play {
    min-width: 44px;
    min-height: 44px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }

  /* Favorite stars and scan icons always visible (no hover on touch) */
  .fav-star, .scan-icon { opacity: 1; }

  /* Card-style messages for mobile */
  .msg {
    flex-direction: column;
    padding: 6px 10px;
    gap: 2px;
    position: relative;
  }
  .msg .ts {
    position: absolute;
    right: 10px;
    top: 6px;
    font-size: 11px;
    min-width: auto;
  }
  .msg .nick {
    font-weight: 600;
    max-width: none !important;
    width: auto !important;
    min-width: auto;
    text-align: left;
    padding-right: 60px; /* space for timestamp */
  }
  .msg .body {
    padding-left: 0;
    font-size: 14px;
    line-height: 1.5;
  }
  .msg.emergency {
    border-left: 3px solid var(--danger);
    background: none;
  }
}

/* Desktop: hide mobile-only elements */
@media (min-width: 769px) {
  .mobile-hamburger { display: none; }
  .mobile-users-btn { display: none; }
  .drawer-backdrop { display: none !important; }
}
</style>
</head>
<body>

<div class="titlebar">
  <button class="mobile-hamburger" id="mobile-hamburger" aria-label="Open channels">â˜°</button>
  <span class="server">tr-engine</span>
  <span>â€”</span>
  <span id="titlebar-chan">*status</span>
  <span class="topic" id="titlebar-topic">Connecting...</span>
  <button class="mobile-hamburger mobile-users-btn" id="mobile-users-btn" aria-label="Open users">ğŸ‘¥</button>
  <span class="lag" id="titlebar-lag"></span>
</div>

<div class="main">
  <div class="drawer-backdrop" id="drawer-backdrop"></div>
  <div class="channel-tree">
    <div class="tree-header-row">
      <span class="tree-header-text">tr-engine</span>
      <button class="read-all-btn" id="read-all-btn">Read All</button>
    </div>
    <div class="tree-search">
      <input class="tree-search-input" id="tree-search" type="text"
             placeholder="Search channels..." spellcheck="false" autocomplete="off">
      <span class="tree-search-clear" id="tree-search-clear">âœ•</span>
    </div>
    <div class="tree-scroll" id="tree-scroll"></div>
    <div class="tree-status" id="tree-status">
      <span class="dot connecting"></span>Connecting...
    </div>
  </div>

  <div class="chat-area">
    <div class="channel-bar">
      <span class="chan-name" id="chan-name">*status</span>
      <span class="chan-mode" id="chan-mode"></span>
      <span class="chan-topic" id="chan-topic">Connecting to tr-engine...</span>
      <span class="chan-count" id="chan-count"></span>
    </div>
    <div class="messages" id="messages"></div>
    <div class="typing-bar" id="typing-bar"></div>
    <div class="player-bar" id="player-bar">
      <div class="player-inner">
        <button class="player-btn" id="player-play" title="Play/Pause">â–¶</button>
        <div class="player-info">
          <span class="player-nick" id="player-nick"></span>
          <span class="player-chan" id="player-chan"></span>
          <span class="player-time" id="player-time">0:00 / 0:00</span>
        </div>
        <div class="player-progress" id="player-progress">
          <div class="player-progress-fill" id="player-progress-fill"></div>
        </div>
        <button class="player-btn player-skip" id="player-skip" title="Skip to next">â­</button>
        <button class="player-btn player-close" id="player-close" title="Close">âœ•</button>
      </div>
    </div>
    <div class="input-area">
      <div class="input-prompt" id="input-prompt">[*status]</div>
      <input class="input-field" id="input-field" type="text" placeholder="Type /help for commands" spellcheck="false" autocomplete="off">
    </div>
  </div>

  <div class="nicklist">
    <div class="nicklist-header" id="nicklist-header">Users</div>
    <div class="nicklist-entries" id="nicklist-entries"></div>
  </div>
</div>

<div class="statusbar">
  <span class="status-ok" id="status-dot">â—</span>
  <span id="status-server">tr-engine</span>
  <span class="sep">â”‚</span>
  <span id="status-channels">0 channels</span>
  <span class="sep">â”‚</span>
  <span id="status-users">0 users</span>
  <span class="sep">â”‚</span>
  <span>Events: <span class="status-highlight" id="status-rate">0</span>/min</span>
  <span class="sep">â”‚</span>
  <span id="status-time"></span>
  <button class="scanner-btn" id="scanner-btn" title="Toggle scanner mode">scan</button>
  <span class="scanner-queue-info" id="scanner-queue-info"></span>
  <button class="nerd-btn" id="nerd-btn" title="Toggle hipster nerd cool mode">nerd</button>
</div>
<div class="nick-tooltip" id="nick-tooltip"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TODO â€” Enhancement ideas
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// [x] Favorite/pinned channels â€” star channels to pin at top of tree (localStorage)
// [x] Channel search box â€” filter input at top of tree for instant name filtering
// [ ] Emergency flash in tree â€” pulse channel name red on emergency calls
// [x] Scanner mode â€” toggle to auto-play audio as transmissions arrive
// [ ] Keyboard channel nav â€” Alt+Up/Down to cycle channels with activity
// [ ] Transmission count on nicks â€” show count next to dot (e.g. "â—12")
// [ ] Desktop notifications â€” browser notifications for backgrounded tab activity
// [x] Unit info on hover â€” tooltip with system, unit ID, status, last TX time
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONFIG â€” set your tr-engine base URL
// Override via query param: ?api=http://localhost:3000/api/v1
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const params = new URLSearchParams(location.search);
const API_BASE = (params.get('api') || '/api/v1').replace(/\/+$/, '');

const MAX_MESSAGES = 500;        // per channel scrollback
const NICK_WIDTH = 130;          // px
const TYPING_DURATION = 3000;    // ms

// â”€â”€ Op patterns: comma-separated regexes matched against unit nicks â”€â”€
// Units matching any pattern get @ (op) status in the nicklist.
// Edit here or use /ops at runtime. Stored in localStorage.
const DEFAULT_OP_PATTERNS = 'LocutionLCD,\\dCOM,CHF,CAPT,BATT,Desk';

// â”€â”€ Nick color palette â”€â”€
const NICK_COLORS = [
  'var(--cyan)', 'var(--green)', 'var(--orange)',
  'var(--magenta)', 'var(--warning)', 'var(--info)',
  'var(--danger)', 'var(--success)', 'var(--rose)', 'var(--lime)',
];
function nickColor(nick) {
  let h = 0;
  for (let i = 0; i < nick.length; i++) h = ((h << 5) - h + nick.charCodeAt(i)) | 0;
  return NICK_COLORS[Math.abs(h) % NICK_COLORS.length];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Channel registry: keyed by IRC-style name (#alpha-tag)
// { chanName: { tgid, system_id, alpha_tag, description, tag, group, mode, users: Map<unit_id, {nick, prefix, role}>, messages: [] } }
const channels = new Map();
const channelUnread = new Map();

// Reverse lookups
const tgidToChannel = new Map();   // `${system_id}:${tgid}` â†’ chanName
const unitNickCache = new Map();   // `${system_id}:${unit_id}` â†’ alpha_tag
const systemNames = new Map();     // system_id â†’ system_name

// Active channel
let activeChannel = '*status';

// Status channel for server messages
const STATUS_CHANNEL = '*status';

// Connection state
let sseConnection = null;
let connectionState = 'disconnected'; // connecting, connected, disconnected
let reconnectTimer = null;
let lastEventId = null;
let eventRate = [];

// Typing state: Map<chanName, { nick, timeout }>
const typingState = new Map();

// Active calls tracker: Map<call_id, { tgid, system_id, units, start }>
const activeCalls = new Map();

// Pending transcriptions: transcription SSE events that arrived before messages were rendered.
// Map<call_id, { system_id, tgid, text, ... }> â€” applied when messages appear.
const pendingTranscriptions = new Map();

// Activity tracking for channel tree collapse
const channelHasActivity = new Set();   // channels with real messages
const groupCollapsed = new Map();       // group collapse state (true = show all, false = collapsed)
const channelLoading = new Set();       // prevent duplicate lazy-loads
const channelLoadedCallIds = new Map(); // chanName -> Set<callId> â€” deduplicate across bootstrap and lazy load
const channelLoadedEventIds = new Map(); // chanName -> Set<eventId> â€” deduplicate unit events across bootstrap and lazy load

// â”€â”€ DOM refs â”€â”€
const messagesEl = document.getElementById('messages');
const typingBar = document.getElementById('typing-bar');
const inputField = document.getElementById('input-field');
const chanNameEl = document.getElementById('chan-name');
const chanTopicEl = document.getElementById('chan-topic');
const chanModeEl = document.getElementById('chan-mode');
const chanCountEl = document.getElementById('chan-count');
const nicklistHeader = document.getElementById('nicklist-header');
const nicklistEntries = document.getElementById('nicklist-entries');
const titlebarChan = document.getElementById('titlebar-chan');
const titlebarTopic = document.getElementById('titlebar-topic');
const titlebarLag = document.getElementById('titlebar-lag');
const treeScroll = document.getElementById('tree-scroll');
const treeStatus = document.getElementById('tree-status');
const statusDot = document.getElementById('status-dot');
const statusServer = document.getElementById('status-server');
const statusChannelsEl = document.getElementById('status-channels');
const statusUsersEl = document.getElementById('status-users');
const statusRate = document.getElementById('status-rate');
const statusTime = document.getElementById('status-time');
const inputPrompt = document.getElementById('input-prompt');

// Search state
let treeSearchQuery = '';
const treeSearchInput = document.getElementById('tree-search');
const treeSearchClear = document.getElementById('tree-search-clear');

let searchTimer = 0;
treeSearchInput.addEventListener('input', () => {
  treeSearchQuery = treeSearchInput.value.trim().toLowerCase();
  treeSearchClear.classList.toggle('visible', treeSearchQuery.length > 0);
  clearTimeout(searchTimer);
  searchTimer = setTimeout(renderTree, 150);
});
treeSearchClear.addEventListener('click', () => {
  treeSearchInput.value = '';
  treeSearchQuery = '';
  treeSearchClear.classList.remove('visible');
  renderTree();
});

// Favorites: Set of "system_id:tgid" keys
function loadSet(key) {
  try { return new Set(JSON.parse(localStorage.getItem(key) || '[]')); }
  catch { localStorage.removeItem(key); return new Set(); }
}
const favorites = loadSet('irc_favorites');

function saveFavorites() {
  localStorage.setItem('irc_favorites', JSON.stringify([...favorites]));
}

function isFavorite(chanName) {
  const ch = channels.get(chanName);
  if (!ch) return false;
  return favorites.has(`${ch.system_id}:${ch.tgid}`);
}

function toggleFavorite(chanName) {
  const ch = channels.get(chanName);
  if (!ch) return;
  const key = `${ch.system_id}:${ch.tgid}`;
  if (favorites.has(key)) favorites.delete(key);
  else favorites.add(key);
  saveFavorites();
  renderTree();
}

// Scanner mode
const scanChannels = loadSet('irc_scan_channels');
let scannerEnabled = localStorage.getItem('irc_scanner_enabled') === '1';
let scannerAutoSwitch = localStorage.getItem('irc_scanner_auto_switch') !== '0'; // default ON

function saveScanChannels() {
  localStorage.setItem('irc_scan_channels', JSON.stringify([...scanChannels]));
}

function isScanned(chanName) {
  const ch = channels.get(chanName);
  if (!ch) return false;
  return scanChannels.has(`${ch.system_id}:${ch.tgid}`);
}

function toggleScan(chanName) {
  const ch = channels.get(chanName);
  if (!ch) return;
  const key = `${ch.system_id}:${ch.tgid}`;
  if (scanChannels.has(key)) scanChannels.delete(key);
  else scanChannels.add(key);
  saveScanChannels();
  renderTree();
}

// Scanner audio queue
const scannerQueue = []; // Array of { callId, nick, chanName, emergency }
const SCANNER_MAX_QUEUE = 10;
let scannerPlaying = false;

function scannerEnqueue(callId, nick, chanName, emergency) {
  if (!scannerEnabled) return;
  if (!isScanned(chanName)) return;

  // Emergency calls go to front of queue (after currently playing)
  if (emergency) {
    if (scannerQueue.length >= SCANNER_MAX_QUEUE) {
      scannerQueue.pop(); // drop oldest non-emergency from end
    }
    scannerQueue.splice(0, 0, { callId, nick, chanName, emergency });
  } else {
    // Overflow protection
    if (scannerQueue.length >= SCANNER_MAX_QUEUE) {
      const dropped = scannerQueue.length - SCANNER_MAX_QUEUE + 1;
      scannerQueue.splice(0, dropped);
      addMsg(STATUS_CHANNEL, { ts: ts(), kind: 'notice',
        text: `Scanner: skipped ${dropped} transmission(s) \u2014 queue overflow` });
    }
    scannerQueue.push({ callId, nick, chanName, emergency });
  }
  updateScannerQueueUI();

  // If nothing is playing, start playback
  if (!scannerPlaying) scannerPlayNext();
}

function scannerPlayNext() {
  if (scannerQueue.length === 0) {
    scannerPlaying = false;
    updateScannerQueueUI();
    return;
  }

  scannerPlaying = true;
  const item = scannerQueue.shift();
  updateScannerQueueUI();

  // Auto-switch channel if enabled
  if (scannerAutoSwitch && item.chanName !== activeChannel) {
    switchChannel(item.chanName);
  }

  // Find the message element for this call in the active channel
  let msgEl = null;
  if (item.chanName === activeChannel) {
    msgEl = messagesEl.querySelector(`[data-call-id="${item.callId}"]`);
  }

  // Play the call audio
  playCall(item.callId, item.nick, item.chanName, msgEl);
}

function updateScannerQueueUI() {
  const info = document.getElementById('scanner-queue-info');
  if (!info) return;
  if (!scannerEnabled || (scannerQueue.length === 0 && !scannerPlaying)) {
    info.textContent = '';
  } else {
    const total = scannerQueue.length + (scannerPlaying ? 1 : 0);
    info.textContent = total > 1 ? `(${total} queued)` : '';
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function ts(date) {
  const d = date || new Date();
  const time = d.toTimeString().slice(0, 5);
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const msgDay = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  if (msgDay.getTime() >= todayStart.getTime()) return time;
  const m = d.getMonth() + 1;
  const day = d.getDate();
  return `${m}/${day} ${time}`;
}

function tsLong(date) {
  const d = date || new Date();
  return d.toTimeString().slice(0, 8);
}

const MONTHS_SHORT = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const DAYS_LONG = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

function formatDateSeparator(date) {
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const msgDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const diff = Math.round((todayStart - msgDay) / 86400000);
  if (diff === 0) return 'Today';
  if (diff === 1) return 'Yesterday';
  if (diff < 7) return DAYS_LONG[date.getDay()];
  return `${DAYS_LONG[date.getDay()]}, ${MONTHS_SHORT[date.getMonth()]} ${date.getDate()}`;
}

let lastRenderedDateStr = '';

/** Convert a talkgroup alpha_tag to an IRC channel name */
function toChannelName(alphaTag) {
  if (!alphaTag) return '#unknown';
  // Replace spaces and special chars with hyphens, collapse runs
  let name = alphaTag.replace(/[\s\/\\]+/g, '-').replace(/[^a-zA-Z0-9\-_.]/g, '').replace(/-+/g, '-').replace(/^-|-$/g, '');
  return '#' + (name || 'unknown');
}

/** Sanitize a unit alpha_tag into an IRC nick */
function toNick(alphaTag, unitId) {
  if (alphaTag && alphaTag.trim()) {
    return alphaTag.trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_\-\[\]{}|]/g, '');
  }
  return 'unit-' + unitId;
}

/** Determine user role from nick/alpha_tag */
function getOpPatterns() { return localStorage.getItem('op_patterns') || DEFAULT_OP_PATTERNS; }
function buildOpRegex(csv) { return new RegExp(csv.split(',').map(s => s.trim()).filter(Boolean).join('|'), 'i'); }
let opRegex = buildOpRegex(getOpPatterns());
function roleForNick(nick) {
  if (!nick) return 'regular';
  return opRegex.test(nick) ? 'op' : 'regular';
}
function reapplyRoles() {
  for (const ch of channels.values()) {
    for (const u of ch.users.values()) {
      u.role = roleForNick(u.nick);
      u.prefix = u.role === 'op' ? '@' : '';
    }
  }
  renderNicklist();
}

/** Nick tooltip */
const nickTooltip = document.getElementById('nick-tooltip');
let tooltipTimer = null;

function findUserByNick(nick) {
  // Search active channel first, then all channels
  const state = channels.get(activeChannel);
  if (state) {
    for (const u of state.users.values()) {
      if (u.nick === nick) return { user: u, channel: activeChannel, chState: state };
    }
  }
  for (const [chName, ch] of channels) {
    for (const u of ch.users.values()) {
      if (u.nick === nick) return { user: u, channel: chName, chState: ch };
    }
  }
  return null;
}

function getLastTxTime(nick) {
  const state = channels.get(activeChannel);
  if (!state) return null;
  for (let i = state.messages.length - 1; i >= 0; i--) {
    if (state.messages[i].nick === nick) return state.messages[i].date || null;
  }
  return null;
}

function countTx(nick) {
  const state = channels.get(activeChannel);
  if (!state) return 0;
  let n = 0;
  for (const m of state.messages) { if (m.nick === nick) n++; }
  return n;
}

function showNickTooltip(nick, el) {
  clearTimeout(tooltipTimer);
  const found = findUserByNick(nick);
  if (!found) return;
  const { user, chState } = found;

  const sysName = systemNames.get(user.systemId) || `System ${user.systemId}`;
  const online = user.online !== false;
  const statusHtml = online
    ? '<span class="tt-online">online</span>'
    : '<span class="tt-offline">offline</span>';
  const lastTx = getLastTxTime(nick);
  const txCount = countTx(nick);

  let html = `<span class="tt-nick">${esc(nick)}</span><br>`;
  html += `<span class="tt-label">Unit:</span> ${user.unitId}<br>`;
  html += `<span class="tt-label">System:</span> ${esc(sysName)}<br>`;
  html += `<span class="tt-label">Status:</span> ${statusHtml}`;
  if (user.role === 'op') html += ` <span class="tt-label">(op)</span>`;
  if (txCount > 0) {
    html += `<br><span class="tt-label">TX in history:</span> ${txCount}`;
  }
  if (lastTx) {
    html += `<br><span class="tt-label">Last TX:</span> ${ts(lastTx)}`;
  }

  nickTooltip.innerHTML = html;
  nickTooltip.style.display = 'block';

  const rect = el.getBoundingClientRect();
  let left = rect.right + 8;
  let top = rect.top;

  // If tooltip would overflow right side, position to the left
  const ttWidth = nickTooltip.offsetWidth;
  if (left + ttWidth > window.innerWidth - 10) {
    left = rect.left - ttWidth - 8;
  }
  // Keep within viewport vertically
  const ttHeight = nickTooltip.offsetHeight;
  if (top + ttHeight > window.innerHeight - 10) {
    top = window.innerHeight - ttHeight - 10;
  }

  nickTooltip.style.left = left + 'px';
  nickTooltip.style.top = top + 'px';
}

function hideNickTooltip() {
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(() => { nickTooltip.style.display = 'none'; }, 100);
}

/** Format frequency in MHz */
function fmtFreq(hz) {
  if (!hz) return '';
  return (hz / 1e6).toFixed(4) + ' MHz';
}

/** Format duration */
function fmtDuration(sec) {
  if (!sec && sec !== 0) return '';
  if (sec < 60) return sec.toFixed(1) + 's';
  return Math.floor(sec / 60) + 'm' + Math.floor(sec % 60) + 's';
}

/** Format transcription text for IRC display â€” clean spacing. */
function fmtTranscript(text) {
  if (!text) return '';
  return text
    .replace(/\s+/g, ' ')   // collapse whitespace runs
    .trim();
}

/** Fuzzy channel match: exact â†’ substring â†’ stripped alphanumeric substring */
function fuzzyMatchChannel(input) {
  const exact = '#' + input;
  if (channels.has(exact)) return exact;

  const lower = input.toLowerCase();
  // Substring match on channel name
  for (const name of channels.keys()) {
    if (name.toLowerCase().includes(lower)) return name;
  }

  // Strip non-alphanumeric from both input and channel names, then substring match
  const stripped = lower.replace(/[^a-z0-9]/g, '');
  if (!stripped) return null;
  let best = null;
  let bestLen = Infinity;
  for (const name of channels.keys()) {
    const nameStripped = name.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (nameStripped.includes(stripped)) {
      // Prefer shortest match (most specific)
      if (nameStripped.length < bestLen) {
        best = name;
        bestLen = nameStripped.length;
      }
    }
  }
  return best;
}

/** Composite key for tgid lookup */
function tgKey(systemId, tgid) { return `${systemId}:${tgid}`; }
function unitKey(systemId, unitId) { return `${systemId}:${unitId}`; }


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHANNEL MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function initStatusChannel() {
  channels.set(STATUS_CHANNEL, {
    tgid: null, system_id: null,
    alpha_tag: 'status', description: 'Server messages',
    tag: '', group: 'System', mode: '',
    users: new Map(), messages: [],
  });
  channelUnread.set(STATUS_CHANNEL, 0);
}

function ensureChannel(tg) {
  const key = tgKey(tg.system_id, tg.tgid);
  if (tgidToChannel.has(key)) return tgidToChannel.get(key);

  if (tg.system_name && !systemNames.has(tg.system_id)) systemNames.set(tg.system_id, tg.system_name);
  const chanName = toChannelName(tg.alpha_tag || tg.tg_alpha_tag);

  // Handle collisions â€” append tgid if needed
  let finalName = chanName;
  if (channels.has(finalName)) {
    const existing = channels.get(finalName);
    if (existing.tgid !== tg.tgid || existing.system_id !== tg.system_id) {
      finalName = chanName + '-' + tg.tgid;
    }
  }

  if (!channels.has(finalName)) {
    channels.set(finalName, {
      tgid: tg.tgid,
      system_id: tg.system_id,
      alpha_tag: tg.alpha_tag || tg.tg_alpha_tag || `TG ${tg.tgid}`,
      description: tg.description || tg.tg_description || '',
      tag: tg.tag || tg.tg_tag || '',
      group: tg.group || tg.tg_group || 'Ungrouped',
      mode: '+nt',
      users: new Map(),
      messages: [],
      historyExhausted: false,
    });
    channelUnread.set(finalName, 0);
  }

  tgidToChannel.set(key, finalName);
  return finalName;
}

function resolveChannel(systemId, tgid) {
  return tgidToChannel.get(tgKey(systemId, tgid));
}

function resolveNick(systemId, unitId, alphaTag) {
  const key = unitKey(systemId, unitId);
  if (alphaTag && alphaTag.trim()) {
    const nick = toNick(alphaTag, unitId);
    unitNickCache.set(key, nick);
    return nick;
  }
  if (unitNickCache.has(key)) return unitNickCache.get(key);
  const fallback = toNick(null, unitId);
  unitNickCache.set(key, fallback);
  return fallback;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MESSAGE RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function addMsg(channel, msg) {
  const state = channels.get(channel);
  if (!state) return;

  state.messages.push(msg);
  if (state.messages.length > MAX_MESSAGES) {
    state.messages.shift();
    if (channel === activeChannel) messagesEl.firstChild?.remove();
  }

  // Track live activity â€” real messages (not notices/topic/mode) promote channels
  if (msg.kind !== 'notice' && msg.kind !== 'topic' && msg.kind !== 'mode') {
    if (!channelHasActivity.has(channel)) {
      channelHasActivity.add(channel);
      renderTree();
    }
  }

  if (channel === activeChannel) {
    appendMsgDOM(msg);
    // Auto-scroll if near bottom
    const atBottom = messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < 80;
    if (atBottom) messagesEl.scrollTop = messagesEl.scrollHeight;
  } else {
    channelUnread.set(channel, (channelUnread.get(channel) || 0) + 1);
    renderTree();
  }

  eventRate.push(Date.now());
}

/** Build a DOM element for a message (content only, no append or call-group context). */
function buildMsgEl(m) {
  const div = document.createElement('div');
  let classes = 'msg';
  if (m.kind) classes += ` ${m.kind}`;
  if (m.emergency) classes += ' emergency';
  if (m.encrypted) classes += ' encrypted';
  div.className = classes;

  const isSystem = ['join', 'part', 'quit', 'mode', 'topic', 'notice'].includes(m.kind);
  const isAction = m.kind === 'action';

  if (isSystem) {
    div.innerHTML = `<span class="ts">${esc(m.ts)}</span><span class="prefix">***</span><span class="body"> ${esc(m.text)}</span>`;
    div.classList.add('system');
  } else if (isAction) {
    div.innerHTML = `<span class="ts">${esc(m.ts)}</span><span class="prefix">*</span><span class="body"> ${esc(m.nick)} ${esc(m.text)}</span>`;
    div.classList.add('system');
  } else {
    const color = nickColor(m.nick || '');
    const nickHtml = `<span class="ts">${esc(m.ts)}</span><span class="nick" style="color:${color}" data-nick="${esc(m.nick || '')}">${esc(m.nick || '???')}</span>`;

    // Voice message with audio link (and optional transcription text)
    if (m.callId) {
      const dur = m.duration || '';
      const body = document.createElement('span');
      body.className = 'body';

      if (m.text) {
        // Transcription text with compact audio controls
        const textSpan = document.createElement('span');
        textSpan.className = 'voice-text';
        textSpan.textContent = m.text;
        body.appendChild(textSpan);

        const controls = document.createElement('span');
        controls.className = 'voice-controls';
        const play = document.createElement('span');
        play.className = 'voice-play';
        play.textContent = 'â–¶';
        play.addEventListener('click', (e) => {
          e.preventDefault();
          playCall(m.callId, m.nick, m.channel, div);
        });
        controls.appendChild(play);
        const listen = document.createElement('a');
        listen.className = 'voice-listen';
        listen.textContent = dur || 'listen';
        listen.href = '#';
        listen.addEventListener('click', (e) => {
          e.preventDefault();
          playCall(m.callId, m.nick, m.channel, div);
        });
        controls.appendChild(listen);
        body.appendChild(controls);
      } else {
        // No transcription yet â€” show play button only
        const play = document.createElement('span');
        play.className = 'voice-play';
        play.textContent = 'â–¶';
        body.appendChild(play);

        if (dur) {
          const durSpan = document.createElement('span');
          durSpan.className = 'voice-dur';
          durSpan.textContent = ' ' + dur + ' ';
          body.appendChild(durSpan);
        }

        const listen = document.createElement('a');
        listen.className = 'voice-listen';
        listen.textContent = 'listen';
        listen.href = '#';
        listen.addEventListener('click', (e) => {
          e.preventDefault();
          playCall(m.callId, m.nick, m.channel, div);
        });
        body.appendChild(listen);
      }

      div.innerHTML = nickHtml;
      div.appendChild(body);
    } else {
      div.innerHTML = nickHtml + `<span class="body">${esc(m.text)}</span>`;
    }
  }

  if (m.callId) div.dataset.callId = m.callId;
  return div;
}

function appendMsgDOM(m) {
  // Date separator between days (local midnight boundaries)
  const msgDate = m.date || new Date();
  const dateStr = `${msgDate.getFullYear()}-${msgDate.getMonth()}-${msgDate.getDate()}`;
  if (lastRenderedDateStr && dateStr !== lastRenderedDateStr) {
    const sep = document.createElement('div');
    sep.className = 'date-separator';
    sep.textContent = formatDateSeparator(msgDate);
    messagesEl.appendChild(sep);
  }
  lastRenderedDateStr = dateStr;

  const div = buildMsgEl(m);

  // Call grouping: if consecutive messages share the same callId, bracket them
  if (m.callId) {
    const prev = messagesEl.lastElementChild;
    if (prev && prev.dataset.callId === String(m.callId)) {
      // Previous message is part of the same call
      if (prev.classList.contains('call-group-last')) {
        prev.classList.replace('call-group-last', 'call-group-mid');
      } else if (!prev.classList.contains('call-group-first') && !prev.classList.contains('call-group-mid')) {
        prev.classList.add('call-group-first');
      }
      div.classList.add('call-group-last');
    }
  }

  m._el = div;
  messagesEl.appendChild(div);
}

/** Re-render a single message's DOM element in place (preserves call-group classes and scroll). */
function refreshMsgEl(m) {
  const oldEl = m._el;
  if (!oldEl || !oldEl.parentNode) return;

  const div = buildMsgEl(m);

  // Preserve call-group classes from the old element
  for (const cls of ['call-group-first', 'call-group-mid', 'call-group-last']) {
    if (oldEl.classList.contains(cls)) div.classList.add(cls);
  }

  oldEl.replaceWith(div);
  m._el = div;
}

function esc(s) {
  if (!s) return '';
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

function serverMsg(text) {
  addMsg(STATUS_CHANNEL, { ts: ts(), kind: 'notice', text });
}

function serverMsgTo(channel, text) {
  addMsg(channel, { ts: ts(), kind: 'notice', text });
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TYPING INDICATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showTyping(channel, nick) {
  const existing = typingState.get(channel);
  if (existing) clearTimeout(existing.timeout);

  const timeout = setTimeout(() => {
    typingState.delete(channel);
    if (channel === activeChannel) typingBar.innerHTML = '';
  }, TYPING_DURATION);

  typingState.set(channel, { nick, timeout });
  if (channel === activeChannel) {
    typingBar.innerHTML = `<span class="typing-nick">${esc(nick)}</span> is typing...`;
  }
}

function clearTyping(channel) {
  const existing = typingState.get(channel);
  if (existing) {
    clearTimeout(existing.timeout);
    typingState.delete(channel);
    if (channel === activeChannel) typingBar.innerHTML = '';
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHANNEL TREE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function groupLabelHtml(name) {
  // Split into county prefix and category; only allow line-break between them
  const m = name.match(/^(.*?\(\d+\))\s(.+)$/);
  if (m) return `<span class="nb">${esc(m[1])}</span> <wbr><span class="nb">${esc(m[2])}</span>`;
  return esc(name);
}

function createChannelItem(ch) {
  const el = document.createElement('div');
  const unread = channelUnread.get(ch) || 0;
  el.className = 'channel-item' + (ch === activeChannel ? ' active' : '') + (unread > 0 && ch !== activeChannel ? ' has-activity' : '');

  const prefix = document.createElement('span');
  prefix.className = 'chan-prefix';
  prefix.textContent = '#';
  el.appendChild(prefix);

  const label = document.createElement('span');
  label.className = 'chan-label';
  label.textContent = ch.slice(1);
  el.appendChild(label);

  if (unread > 0 && ch !== activeChannel) {
    const badge = document.createElement('span');
    badge.className = 'unread';
    badge.textContent = unread > 99 ? '99+' : unread;
    el.appendChild(badge);
  }

  // Right-aligned cluster for icons (prevents double margin-left:auto issue with unread badge)
  const rightCluster = document.createElement('span');
  rightCluster.className = 'channel-icons';

  // Scan icon
  const scanIcon = document.createElement('span');
  scanIcon.className = 'scan-icon' + (isScanned(ch) ? ' active' : '');
  scanIcon.textContent = isScanned(ch) ? '\uD83D\uDCE1' : '\uD83D\uDD07';
  scanIcon.title = isScanned(ch) ? 'Remove from scanner' : 'Add to scanner';
  scanIcon.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleScan(ch);
  });
  rightCluster.appendChild(scanIcon);

  // Favorite star
  const star = document.createElement('span');
  star.className = 'fav-star' + (isFavorite(ch) ? ' active' : '');
  star.textContent = isFavorite(ch) ? '\u2605' : '\u2606';
  star.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleFavorite(ch);
  });
  rightCluster.appendChild(star);

  el.appendChild(rightCluster);

  el.addEventListener('click', () => switchChannel(ch));
  return el;
}

function isChannelActive(ch) {
  return channelHasActivity.has(ch) || ch === activeChannel || (channelUnread.get(ch) || 0) > 0;
}

function renderTree() {
  // Group channels by group field
  const groups = new Map();
  for (const [name, ch] of channels) {
    if (name === STATUS_CHANNEL) continue;
    const g = ch.group || 'Ungrouped';
    if (!groups.has(g)) groups.set(g, []);
    groups.get(g).push(name);
  }

  treeScroll.innerHTML = '';

  // If searching, show flat filtered results
  if (treeSearchQuery) {
    const matches = [];
    for (const [name, ch] of channels) {
      if (name === STATUS_CHANNEL) continue;
      const searchable = (name + ' ' + (ch.alpha_tag || '') + ' ' + (ch.group || '')).toLowerCase();
      if (searchable.includes(treeSearchQuery)) matches.push(name);
    }
    matches.sort();
    for (const ch of matches) {
      treeScroll.appendChild(createChannelItem(ch));
    }
    if (matches.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'tree-more';
      empty.textContent = 'No matching channels';
      treeScroll.appendChild(empty);
    }
    return; // skip grouped rendering
  }

  // Status channel first
  const sysSection = document.createElement('div');
  sysSection.className = 'tree-section';
  const sysLabel = document.createElement('div');
  sysLabel.className = 'tree-section-label';
  sysLabel.textContent = 'System';
  sysSection.appendChild(sysLabel);

  const statusItem = document.createElement('div');
  statusItem.className = 'channel-item' + (activeChannel === STATUS_CHANNEL ? ' active' : '');
  statusItem.innerHTML = `<span class="chan-prefix">*</span><span class="chan-label">status</span>`;
  if (channelUnread.get(STATUS_CHANNEL) > 0 && activeChannel !== STATUS_CHANNEL) {
    statusItem.classList.add('has-activity');
  }
  statusItem.addEventListener('click', () => switchChannel(STATUS_CHANNEL));
  sysSection.appendChild(statusItem);
  treeScroll.appendChild(sysSection);

  // Favorites section
  const favChans = [...channels.keys()].filter(ch => ch !== STATUS_CHANNEL && isFavorite(ch));
  if (favChans.length > 0) {
    const favSection = document.createElement('div');
    favSection.className = 'tree-section';
    const favLabel = document.createElement('div');
    favLabel.className = 'tree-section-label fav-label';
    favLabel.textContent = '\u2605 Favorites';
    favSection.appendChild(favLabel);

    favChans.sort();
    for (const ch of favChans) {
      favSection.appendChild(createChannelItem(ch));
    }
    treeScroll.appendChild(favSection);
  }

  // Sort groups alphabetically
  const sortedGroups = [...groups.entries()].sort((a, b) => a[0].localeCompare(b[0]));

  for (const [groupName, chans] of sortedGroups) {
    const section = document.createElement('div');
    section.className = 'tree-section';

    // Sort channels within group
    chans.sort();

    // Split into active and inactive channels
    const activeChans = chans.filter(ch => isChannelActive(ch));
    const inactiveChans = chans.filter(ch => !isChannelActive(ch));

    const isExpanded = groupCollapsed.get(groupName) === true; // explicitly expanded
    const allInactive = activeChans.length === 0;

    // Compute group-level unread total
    const groupUnread = chans.reduce((sum, ch) => sum + (channelUnread.get(ch) || 0), 0);
    const unreadBadge = groupUnread > 0
      ? `<span class="group-unread">${groupUnread > 99 ? '99+' : groupUnread}</span>` : '';

    const label = document.createElement('div');
    label.className = 'tree-section-label';

    if (allInactive && !isExpanded) {
      if (chans.length <= 3) {
        // Small inactive group â€” show all channels directly
        label.innerHTML = groupLabelHtml(groupName) + unreadBadge;
        label.addEventListener('click', () => {
          groupCollapsed.set(groupName, false);
          renderTree();
        });
        section.appendChild(label);
        for (const ch of chans) {
          section.appendChild(createChannelItem(ch));
        }
      } else {
        // Large inactive group â€” collapse with "N more..."
        label.classList.add('collapsed');
        label.innerHTML = groupLabelHtml(groupName) + unreadBadge;
        label.addEventListener('click', () => {
          groupCollapsed.set(groupName, true);
          renderTree();
        });
        section.appendChild(label);

        const more = document.createElement('div');
        more.className = 'tree-more';
        more.textContent = `${chans.length} more...`;
        more.addEventListener('click', (e) => {
          e.stopPropagation();
          groupCollapsed.set(groupName, true);
          renderTree();
        });
        section.appendChild(more);
      }
    } else if (isExpanded) {
      // Fully expanded â€” show all channels
      label.innerHTML = groupLabelHtml(groupName) + unreadBadge;
      label.addEventListener('click', () => {
        groupCollapsed.set(groupName, false);
        renderTree();
      });
      section.appendChild(label);

      for (const ch of chans) {
        section.appendChild(createChannelItem(ch));
      }
    } else {
      // Mixed: show active channels + "N more..." expander for inactive
      label.innerHTML = groupLabelHtml(groupName) + unreadBadge;
      label.addEventListener('click', () => {
        groupCollapsed.set(groupName, true);
        renderTree();
      });
      section.appendChild(label);

      for (const ch of activeChans) {
        section.appendChild(createChannelItem(ch));
      }

      if (inactiveChans.length > 0 && inactiveChans.length <= 3) {
        for (const ch of inactiveChans) {
          section.appendChild(createChannelItem(ch));
        }
      } else if (inactiveChans.length > 3) {
        const more = document.createElement('div');
        more.className = 'tree-more';
        more.textContent = `${inactiveChans.length} more...`;
        more.addEventListener('click', (e) => {
          e.stopPropagation();
          groupCollapsed.set(groupName, true);
          renderTree();
        });
        section.appendChild(more);
      }
    }

    treeScroll.appendChild(section);
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NICKLIST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderNicklist() {
  const state = channels.get(activeChannel);
  if (!state) {
    nicklistHeader.textContent = 'Users';
    nicklistEntries.innerHTML = '';
    return;
  }

  const users = [...state.users.values()];
  // Sort: online first, then alphabetical within each group
  const sortUser = (a, b) => {
    const ao = a.online === false ? 1 : 0;
    const bo = b.online === false ? 1 : 0;
    if (ao !== bo) return ao - bo;
    return a.nick.localeCompare(b.nick);
  };
  const ops = users.filter(u => u.role === 'op').sort(sortUser);
  const voiced = users.filter(u => u.role === 'voice').sort(sortUser);
  const regular = users.filter(u => u.role === 'regular').sort(sortUser);
  const onlineCount = users.filter(u => u.online !== false).length;

  // Collect nicks that have spoken in the displayed history
  const talkedNicks = new Set();
  for (const m of state.messages) {
    if (m.nick) talkedNicks.add(m.nick);
  }

  nicklistHeader.textContent = `Users (${onlineCount}/${users.length})`;
  nicklistEntries.innerHTML = '';

  function addSection(label, list, cls, prefix) {
    if (list.length === 0) return;
    const lbl = document.createElement('div');
    lbl.className = 'nicklist-section-label';
    lbl.textContent = `${label} (${list.length})`;
    nicklistEntries.appendChild(lbl);
    for (const u of list) {
      const el = document.createElement('div');
      el.className = `nick-item ${cls}` + (u.online === false ? ' offline' : '') + (talkedNicks.has(u.nick) ? ' talked' : '');
      el.innerHTML = `<span class="nick-prefix">${prefix}</span>${esc(u.nick)}`;
      el.addEventListener('mouseenter', () => showNickTooltip(u.nick, el));
      el.addEventListener('mouseleave', hideNickTooltip);
      nicklistEntries.appendChild(el);
    }
  }

  addSection('Ops', ops, 'op', '@');
  addSection('Voiced', voiced, 'voice', '+');
  addSection('Users', regular, 'regular', ' ');

  chanCountEl.textContent = `${onlineCount}/${users.length} users`;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHANNEL SWITCHING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function switchChannel(ch) {
  if (!channels.has(ch)) return;
  activeChannel = ch;
  channelUnread.set(ch, 0);

  const state = channels.get(ch);
  const displayName = ch;
  const topic = state.description || state.tag || '';

  chanNameEl.textContent = displayName;
  chanTopicEl.textContent = topic;
  chanModeEl.textContent = state.mode ? `[${state.mode}]` : '';
  titlebarChan.textContent = displayName;
  titlebarTopic.textContent = topic;
  inputPrompt.textContent = `[${displayName}]`;

  // Render messages
  messagesEl.innerHTML = '';
  lastRenderedDateStr = '';
  for (const m of state.messages) appendMsgDOM(m);
  messagesEl.scrollTop = messagesEl.scrollHeight;

  // Load history if this channel hasn't been populated yet, or fill viewport
  if (state.tgid && !channelLoading.has(ch)) {
    if (!channelHasActivity.has(ch)) {
      lazyLoadChannel(ch, state.system_id, state.tgid).then(() => ensureChannelFilled(ch));
    } else {
      ensureChannelFilled(ch);
    }
  }

  // Typing
  const t = typingState.get(ch);
  if (t) typingBar.innerHTML = `<span class="typing-nick">${esc(t.nick)}</span> is typing...`;
  else typingBar.innerHTML = '';

  renderTree();
  renderNicklist();

  // Close mobile drawer on channel switch
  if (window.innerWidth <= 768) closeDrawers();
}

/** Convert API calls into message objects for a channel. Returns messages oldest-first. Deduplicates by call_id. */
function callsToMessages(calls, chanName, systemId) {
  const msgs = [];
  const ch = channels.get(chanName);
  if (!channelLoadedCallIds.has(chanName)) channelLoadedCallIds.set(chanName, new Set());
  const loadedIds = channelLoadedCallIds.get(chanName);
  const sorted = [...calls].reverse(); // API returns newest-first; flip to oldest-first
  for (const call of sorted) {
    if (loadedIds.has(call.call_id)) continue;
    loadedIds.add(call.call_id);
    const srcList = call.src_list || [];
    const isEmergency = call.emergency || false;
    const sid = call.system_id || systemId;

    if (call.encrypted) {
      const units = call.units || [];
      const srcNick = units.length > 0
        ? resolveNick(sid, units[0].unit_id, units[0].alpha_tag)
        : (call.tg_alpha_tag || `TG ${call.tgid}`);
      const callTime = call.start_time ? new Date(call.start_time) : new Date();
      const dur = call.duration ? fmtDuration(call.duration) : '';
      msgs.push({
        ts: ts(callTime), date: callTime, nick: srcNick, encrypted: true,
        text: `[encrypted${dur ? ', ' + dur : ''}]`,
      });
    } else if (srcList.length > 0) {
      const txSorted = [...srcList].sort((a, b) => (a.pos || 0) - (b.pos || 0));
      for (const tx of txSorted) {
        const nick = resolveNick(sid, tx.src, tx.tag);
        const txTime = tx.time ? new Date(tx.time * 1000) : (call.start_time ? new Date(call.start_time) : new Date());
        const dur = tx.duration ? fmtDuration(tx.duration) : '';
        if (ch) ensureUserInChannel(ch, chanName, sid, tx.src, tx.tag);
        msgs.push({
          ts: ts(txTime), date: txTime, nick, src: tx.src, callId: call.call_id,
          pos: tx.pos || 0, txDuration: tx.duration || 0,
          duration: dur, channel: chanName,
          emergency: isEmergency || tx.emergency === 1,
        });
      }
    } else {
      const units = call.units || [];
      const srcNick = units.length > 0
        ? resolveNick(sid, units[0].unit_id, units[0].alpha_tag)
        : (call.tg_alpha_tag || `TG ${call.tgid}`);
      const callTime = call.start_time ? new Date(call.start_time) : new Date();
      const dur = call.duration ? fmtDuration(call.duration) : '';
      msgs.push({
        ts: ts(callTime), date: callTime, nick: srcNick, callId: call.call_id,
        duration: dur, channel: chanName, emergency: isEmergency,
      });
    }
  }
  return msgs;
}

/** Convert API unit events into IRC-style message objects. Returns messages oldest-first. Deduplicates by event id. */
function unitEventsToMessages(events, chanName) {
  const msgs = [];
  const ch = channels.get(chanName);
  if (!channelLoadedEventIds.has(chanName)) channelLoadedEventIds.set(chanName, new Set());
  const loadedIds = channelLoadedEventIds.get(chanName);

  const sorted = [...events].reverse(); // API returns newest-first; flip to oldest-first
  for (const evt of sorted) {
    if (loadedIds.has(evt.id)) continue;
    loadedIds.add(evt.id);

    const nick = resolveNick(evt.system_id, evt.unit_rid, evt.unit_alpha_tag);
    const evtTime = new Date(evt.time);

    if (evt.event_type === 'join') {
      if (ch) ensureUserInChannel(ch, chanName, evt.system_id, evt.unit_rid, evt.unit_alpha_tag);
      msgs.push({
        ts: ts(evtTime), date: evtTime,
        kind: 'join', text: `${nick} has joined ${chanName}`,
      });
    } else if (evt.event_type === 'off') {
      msgs.push({
        ts: ts(evtTime), date: evtTime,
        kind: 'quit', text: `${nick} has quit (Quit)`,
      });
    }
  }
  return msgs;
}

/** Merge two message arrays by date (oldest-first). */
function mergeByTime(a, b) {
  const merged = [...a, ...b];
  merged.sort((x, y) => (x.date || 0) - (y.date || 0));
  return merged;
}

const HISTORY_PAGE_SIZE = 50;

async function lazyLoadChannel(chanName, systemId, tgid) {
  channelLoading.add(chanName);
  const ch = channels.get(chanName);
  if (!ch) { channelLoading.delete(chanName); return; }

  try {
    // Time-cursor pagination: use oldest message's date as the upper bound
    const oldest = ch.messages.length > 0 ? ch.messages[0].date : null;
    const endParam = oldest ? `&end_time=${oldest.toISOString()}` : '';

    const [callData, eventData] = await Promise.all([
      fetchJSON(`/calls?tgid=${tgid}&system_id=${systemId}&sort=-stop_time&deduplicate=true&limit=${HISTORY_PAGE_SIZE}${endParam}`),
      fetchJSON(`/unit-events?tgid=${tgid}&system_id=${systemId}&type=join,off&sort=-time&limit=${HISTORY_PAGE_SIZE}${endParam}`),
    ]);
    const calls = callData.calls || [];
    const events = eventData.events || [];

    if (calls.length < HISTORY_PAGE_SIZE && events.length < HISTORY_PAGE_SIZE) ch.historyExhausted = true;

    if (calls.length === 0 && events.length === 0) {
      channelLoading.delete(chanName);
      return;
    }

    const callMsgs = callsToMessages(calls, chanName, systemId);
    const eventMsgs = unitEventsToMessages(events, chanName);
    const newMsgs = mergeByTime(callMsgs, eventMsgs);

    // Prepend older messages to the beginning of the channel's messages array
    ch.messages.unshift(...newMsgs);

    // Trim excess from the end if needed
    while (ch.messages.length > MAX_MESSAGES) ch.messages.pop();

    channelHasActivity.add(chanName);

    // Re-render if still on this channel, preserving scroll position
    if (activeChannel === chanName) {
      const prevScrollTop = messagesEl.scrollTop;
      const prevScrollHeight = messagesEl.scrollHeight;
      const wasAtBottom = prevScrollHeight - prevScrollTop - messagesEl.clientHeight < 80;
      messagesEl.innerHTML = '';
      lastRenderedDateStr = '';
      for (const m of ch.messages) appendMsgDOM(m);
      const newScrollHeight = messagesEl.scrollHeight;
      if (wasAtBottom && prevScrollHeight <= messagesEl.clientHeight) {
        // First load or content didn't fill viewport â€” scroll to bottom
        messagesEl.scrollTop = newScrollHeight;
      } else {
        // Preserve view: offset by the height of prepended content
        messagesEl.scrollTop = prevScrollTop + (newScrollHeight - prevScrollHeight);
      }
      renderNicklist();
    }
    renderTree();

    // Fetch transcriptions for loaded calls (async, non-blocking)
    const callIds = calls.map(c => c.call_id).filter(Boolean);
    fetchTranscriptionsForCalls(callIds);
  } catch (err) {
    serverMsgTo(chanName, `Failed to load history: ${err.message}`);
  } finally {
    channelLoading.delete(chanName);
  }
}


/** Keep loading older history until the messages area is scrollable or data is exhausted. */
async function ensureChannelFilled(chanName) {
  const ch = channels.get(chanName);
  if (!ch || !ch.tgid || ch.historyExhausted || channelLoading.has(chanName)) return;
  if (activeChannel !== chanName) return;

  // If content already fills the viewport, nothing to do
  if (messagesEl.scrollHeight > messagesEl.clientHeight + 40) return;

  await lazyLoadChannel(chanName, ch.system_id, ch.tgid);

  // Recurse until filled or exhausted
  if (activeChannel === chanName && !ch.historyExhausted) {
    ensureChannelFilled(chanName);
  }
}

// Scroll-to-top handler: load older messages when scrolling up
messagesEl.addEventListener('scroll', () => {
  if (messagesEl.scrollTop > 100) return; // not near top
  if (!activeChannel || activeChannel === STATUS_CHANNEL) return;
  const ch = channels.get(activeChannel);
  if (!ch || !ch.tgid || ch.historyExhausted || channelLoading.has(activeChannel)) return;
  lazyLoadChannel(activeChannel, ch.system_id, ch.tgid);
});


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// API FETCHING â€” Bootstrap channels & nicklists
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function fetchJSON(path) {
  const res = await fetch(API_BASE + path);
  if (!res.ok) throw new Error(`${res.status} ${res.statusText} from ${path}`);
  return res.json();
}

async function bootstrapChannels() {
  serverMsg(`Fetching channel list from ${API_BASE}/talkgroups...`);
  try {
    const data = await fetchJSON('/talkgroups?limit=1000&sort=alpha_tag');
    const tgs = data.talkgroups || [];
    serverMsg(`Received ${tgs.length} talkgroups`);

    for (const tg of tgs) {
      const chanName = ensureChannel(tg);
      // Initial join message
      channels.get(chanName).messages.push({
        ts: ts(), kind: 'notice',
        text: `Now talking on ${chanName}`,
      });
      channels.get(chanName).messages.push({
        ts: ts(), kind: 'topic',
        text: `Topic for ${chanName}: ${tg.description || tg.alpha_tag} [${tg.tag || ''}]`,
      });
      if (tg.mode) {
        channels.get(chanName).messages.push({
          ts: ts(), kind: 'mode',
          text: `${chanName} mode: ${tg.mode}`,
        });
      }
    }

    serverMsg(`Joined ${channels.size - 1} channels`);
    renderTree();

    // Auto-switch to first real channel
    const firstChan = [...channels.keys()].find(k => k !== STATUS_CHANNEL);
    if (firstChan) switchChannel(firstChan);
  } catch (err) {
    serverMsg(`ERROR fetching talkgroups: ${err.message}`);
  }
}

async function bootstrapAffiliations() {
  serverMsg('Fetching user affiliations...');
  try {
    const data = await fetchJSON('/unit-affiliations?limit=5000');
    const affs = data.affiliations || [];
    serverMsg(`Received ${affs.length} affiliations`);

    let userCount = 0;
    let offlineCount = 0;
    for (const aff of affs) {
      const chanName = resolveChannel(aff.system_id, aff.tgid);
      if (!chanName) continue;

      const ch = channels.get(chanName);
      if (!ch) continue;

      const nick = resolveNick(aff.system_id, aff.unit_id, aff.unit_alpha_tag);
      const role = roleForNick(nick);
      const prefix = role === 'op' ? '@' : '';
      const online = aff.status === 'affiliated';

      const uk = unitKey(aff.system_id, aff.unit_id);
      if (!ch.users.has(uk)) {
        ch.users.set(uk, { nick, prefix, role, unitId: aff.unit_id, systemId: aff.system_id, online });
        userCount++;
        if (!online) offlineCount++;
      }
    }

    serverMsg(`${userCount} users loaded across channels (${userCount - offlineCount} online, ${offlineCount} offline)`);
    renderNicklist();
    renderTree();
  } catch (err) {
    serverMsg(`ERROR fetching affiliations: ${err.message}`);
  }
}

async function bootstrapRecentCalls() {
  serverMsg('Fetching recent activity (30 min)...');
  try {
    const since = new Date(Date.now() - 30 * 60 * 1000).toISOString();
    const [callData, eventData] = await Promise.all([
      fetchJSON(`/calls?sort=-stop_time&deduplicate=true&limit=500&start_time=${since}`),
      fetchJSON(`/unit-events?type=join,off&sort=-time&limit=500&start_time=${since}`),
    ]);
    const calls = callData.calls || [];
    const events = eventData.events || [];

    // Group calls by channel
    const callsByChannel = new Map();
    for (const call of calls) {
      const chanName = resolveChannel(call.system_id, call.tgid);
      if (!chanName || !channels.has(chanName)) continue;
      if (!callsByChannel.has(chanName)) callsByChannel.set(chanName, []);
      callsByChannel.get(chanName).push(call);
    }

    // Group unit events by channel
    const eventsByChannel = new Map();
    for (const evt of events) {
      const chanName = evt.tgid ? resolveChannel(evt.system_id, evt.tgid) : null;
      if (!chanName || !channels.has(chanName)) continue;
      if (!eventsByChannel.has(chanName)) eventsByChannel.set(chanName, []);
      eventsByChannel.get(chanName).push(evt);
    }

    // All channels that got either calls or events
    const allChannels = new Set([...callsByChannel.keys(), ...eventsByChannel.keys()]);

    // Track which channels got backfill messages (for unread counts)
    const backfillCounts = new Map();

    for (const chanName of allChannels) {
      const ch = channels.get(chanName);
      if (!ch) continue;

      const chanCalls = callsByChannel.get(chanName) || [];
      const chanEvents = eventsByChannel.get(chanName) || [];

      const callMsgs = callsToMessages(chanCalls, chanName, ch.system_id);
      const eventMsgs = unitEventsToMessages(chanEvents, chanName);
      const merged = mergeByTime(callMsgs, eventMsgs);

      ch.messages.push(...merged);
      if (merged.length > 0) {
        backfillCounts.set(chanName, merged.length);
      }
    }

    // Set unread badges and activity flags for channels with backfill
    for (const [chanName, count] of backfillCounts) {
      channelHasActivity.add(chanName);
      // Don't set unread for the currently active channel
      if (chanName !== activeChannel) {
        channelUnread.set(chanName, count);
      }
    }

    serverMsg(`Loaded ${calls.length} recent calls and ${events.length} unit events across ${backfillCounts.size} channels`);

    // Re-render if we're on a channel that got backfill
    if (activeChannel !== STATUS_CHANNEL) {
      messagesEl.innerHTML = '';
      lastRenderedDateStr = '';
      const state = channels.get(activeChannel);
      if (state) {
        for (const m of state.messages) appendMsgDOM(m);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }
    }

    renderTree();

    // Fetch transcriptions for loaded calls (async, non-blocking)
    const callIds = calls.map(c => c.call_id).filter(Boolean);
    fetchTranscriptionsForCalls(callIds);
  } catch (err) {
    serverMsg(`ERROR fetching recent activity: ${err.message}`);
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SSE â€” Real-time event stream
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function connectSSE() {
  if (sseConnection) {
    sseConnection.close();
    sseConnection = null;
  }

  setConnectionState('connecting');

  const url = `${API_BASE}/events/stream`;
  serverMsg(`Connecting to ${url}...`);

  const es = new EventSource(url);
  sseConnection = es;

  es.onopen = () => {
    setConnectionState('connected');
    serverMsg('Connected to event stream');
  };

  es.onerror = () => {
    if (connectionState === 'connected') {
      serverMsg('Connection lost, reconnecting...');
    }
    setConnectionState('disconnected');
    // EventSource auto-reconnects
  };

  // â”€â”€ Call events â”€â”€
  es.addEventListener('call_start', (e) => {
    lastEventId = e.lastEventId;
    try { handleCallStart(JSON.parse(e.data)); } catch (err) { console.warn('bad call_start event:', err); }
  });

  es.addEventListener('call_update', (e) => {
    lastEventId = e.lastEventId;
    try { handleCallUpdate(JSON.parse(e.data)); } catch (err) { console.warn('bad call_update event:', err); }
  });

  es.addEventListener('call_end', (e) => {
    lastEventId = e.lastEventId;
    try { handleCallEnd(JSON.parse(e.data)); } catch (err) { console.warn('bad call_end event:', err); }
  });

  // â”€â”€ Unit events â”€â”€
  es.addEventListener('unit_event', (e) => {
    lastEventId = e.lastEventId;
    try { handleUnitEvent(JSON.parse(e.data)); } catch (err) { console.warn('bad unit_event:', err); }
  });

  // â”€â”€ Recorder updates (optional, show as server notices) â”€â”€
  es.addEventListener('recorder_update', (e) => {
    // Silent â€” could log to *status if desired
  });

  es.addEventListener('rate_update', (e) => {
    lastEventId = e.lastEventId;
    try {
      const data = JSON.parse(e.data);
      if (data.decode_rate !== undefined) {
        const pct = (data.decode_rate * 100).toFixed(1);
        titlebarLag.textContent = `decode: ${pct}%`;
      }
    } catch (err) { console.warn('bad rate_update event:', err); }
  });

  // â”€â”€ Transcription events â”€â”€
  es.addEventListener('transcription', (e) => {
    lastEventId = e.lastEventId;
    try { handleTranscription(JSON.parse(e.data)); } catch (err) { console.warn('bad transcription event:', err); }
  });
}

function setConnectionState(state) {
  connectionState = state;
  const dot = treeStatus.querySelector('.dot');

  if (state === 'connected') {
    treeStatus.innerHTML = '<span class="dot connected"></span>Connected';
    statusDot.className = 'status-ok';
    statusDot.textContent = 'â—';
  } else if (state === 'connecting') {
    treeStatus.innerHTML = '<span class="dot connecting"></span>Connecting...';
    statusDot.className = 'status-err';
    statusDot.textContent = 'â—‹';
  } else {
    treeStatus.innerHTML = '<span class="dot disconnected"></span>Disconnected';
    statusDot.className = 'status-err';
    statusDot.textContent = 'â—';
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENT HANDLERS â€” Map SSE events to IRC actions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/** Handle a transcription SSE event â€” inject text into existing call messages. */
async function handleTranscription(data) {
  const callId = data.call_id;
  const chanName = resolveChannel(data.system_id, data.tgid);
  if (!chanName) {
    // Channel not created yet â€” cache with SSE text for later
    pendingTranscriptions.set(callId, { fullText: data.text || '', segments: [], chanName: null });
    return;
  }

  const ch = channels.get(chanName);
  if (!ch) {
    pendingTranscriptions.set(callId, { fullText: data.text || '', segments: [], chanName });
    return;
  }

  // Fetch full transcription with segments for per-unit text
  let segments = [];
  let fullText = data.text || '';
  try {
    const tx = await fetchJSON(`/calls/${callId}/transcription`);
    if (tx.words && tx.words.segments) segments = tx.words.segments;
    if (tx.text) fullText = tx.text;
  } catch (err) {
    // API fetch failed â€” use the full text from the SSE event
  }

  applyTranscriptionToChannel(ch, chanName, callId, fullText, segments);
}

/** Apply transcription text to messages in a channel, matching segments to units.
 *  Uses time-overlap matching: each segment has start/end (seconds from audio start),
 *  each message has pos/txDuration (seconds from audio start). Match by overlap. */
function applyTranscriptionToChannel(ch, chanName, callId, fullText, segments) {
  const callMsgs = ch.messages.filter(m => m.callId === callId);
  if (callMsgs.length === 0) {
    // Messages not rendered yet â€” cache for when they appear
    pendingTranscriptions.set(callId, { fullText, segments, chanName });
    return;
  }
  pendingTranscriptions.delete(callId);

  if (segments.length > 0) {
    const assigned = new Set();

    for (const seg of segments) {
      if (seg.start === 0 && seg.end === 0 && segments.length > 1) continue; // skip empty segments

      let bestIdx = -1;
      let bestOverlap = -1;

      for (let i = 0; i < callMsgs.length; i++) {
        if (assigned.has(i)) continue;
        const m = callMsgs[i];

        // Time-overlap matching: segment start/end vs message pos/txDuration
        if (m.pos !== undefined && m.txDuration > 0 && seg.end > 0) {
          const mEnd = m.pos + m.txDuration;
          const overlapStart = Math.max(seg.start, m.pos);
          const overlapEnd = Math.min(seg.end, mEnd);
          const overlap = overlapEnd - overlapStart;
          if (overlap > bestOverlap) {
            bestOverlap = overlap;
            bestIdx = i;
          }
        } else if (m.src === seg.src && bestIdx === -1) {
          // Fallback: src match (for messages without pos data)
          bestIdx = i;
        }
      }

      if (bestIdx >= 0) {
        callMsgs[bestIdx].text = fmtTranscript(seg.text);
        assigned.add(bestIdx);
      }
    }

    // If nothing matched at all, fall back to simple assignment
    if (assigned.size === 0) {
      if (callMsgs.length === 1) {
        callMsgs[0].text = fmtTranscript(fullText);
      } else {
        for (let i = 0; i < callMsgs.length && i < segments.length; i++) {
          callMsgs[i].text = fmtTranscript(segments[i].text);
        }
      }
    }
  } else if (callMsgs.length === 1) {
    callMsgs[0].text = fmtTranscript(fullText);
  } else {
    // No segments, multiple messages â€” put full text on first
    callMsgs[0].text = fmtTranscript(fullText);
  }

  // Targeted DOM update â€” only refresh messages whose text changed (no full re-render)
  if (chanName === activeChannel) {
    for (const m of callMsgs) refreshMsgEl(m);
  }
}

/** Re-render the active channel's messages. */
function reRenderChannel(chanName) {
  const ch = channels.get(chanName);
  if (!ch || chanName !== activeChannel) return;
  const savedScroll = messagesEl.scrollTop;
  const wasAtBottom = messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < 80;
  messagesEl.innerHTML = '';
  lastRenderedDateStr = '';
  for (const m of ch.messages) appendMsgDOM(m);
  if (wasAtBottom) messagesEl.scrollTop = messagesEl.scrollHeight;
  else messagesEl.scrollTop = savedScroll;
}

/** Apply any pending transcriptions that arrived before messages were rendered. */
function drainPendingTranscriptions(callIds, chanName) {
  const ch = channels.get(chanName);
  if (!ch) return;

  for (const callId of callIds) {
    const pending = pendingTranscriptions.get(callId);
    if (pending) {
      pendingTranscriptions.delete(callId);
      const callMsgs = ch.messages.filter(m => m.callId === callId);
      if (callMsgs.length > 0) {
        applyTranscriptionToChannel(ch, chanName, callId, pending.fullText, pending.segments);
      }
    }
  }

  // Evict stale entries if cache grows too large (shouldn't happen in practice)
  if (pendingTranscriptions.size > 200) {
    const keys = [...pendingTranscriptions.keys()];
    for (let i = 0; i < keys.length - 100; i++) pendingTranscriptions.delete(keys[i]);
  }
}

/** Batch-fetch transcriptions for a list of call IDs and apply to channel messages.
 *  Used by bootstrap/history-load paths for calls loaded from the API. */
async function fetchTranscriptionsForCalls(callIds) {
  if (callIds.length === 0) return;

  // Validate all IDs are integers before building SQL
  const safeIds = callIds.filter(id => Number.isInteger(id) && id > 0);
  if (safeIds.length === 0) return;

  // Use the ad-hoc query endpoint to batch-fetch
  const idList = safeIds.join(',');
  try {
    const resp = await fetch(`${API_BASE}/query`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sql: `SELECT call_id, text, words->'segments' as segments FROM transcriptions WHERE call_id IN (${idList}) AND is_primary = true`,
      }),
    });
    if (!resp.ok) return;
    const data = await resp.json();
    const rows = data.rows || [];
    const cols = data.columns || [];

    // Map column names to indices
    const ci = {};
    cols.forEach((c, i) => ci[c] = i);

    // Build a map of call_id â†’ {text, segments}
    const txMap = new Map();
    for (const row of rows) {
      const cid = row[ci.call_id];
      const rawSeg = row[ci.segments];
      const segments = Array.isArray(rawSeg) ? rawSeg : [];
      txMap.set(cid, { text: row[ci.text] || '', segments });
    }

    // Apply to all channels
    for (const [chanName, ch] of channels) {
      const chanCallIds = new Set(ch.messages.filter(m => m.callId && txMap.has(m.callId)).map(m => m.callId));
      for (const callId of chanCallIds) {
        const tx = txMap.get(callId);
        if (tx) applyTranscriptionToChannel(ch, chanName, callId, tx.text, tx.segments);
      }
    }
  } catch (err) {
    // Silent â€” transcriptions are non-critical
  }
}

function handleCallStart(call) {
  // Ensure channel exists
  const chanName = ensureChannel({
    system_id: call.system_id, tgid: call.tgid,
    alpha_tag: call.tg_alpha_tag, description: call.tg_description,
    tag: call.tg_tag, group: call.tg_group,
  });

  const ch = channels.get(chanName);
  if (!ch) return;

  // Identify first speaker from src_list (preferred) or units fallback
  const srcList = call.src_list || [];
  const units = call.units || [];
  let srcNick = null;

  if (srcList.length > 0) {
    srcNick = resolveNick(call.system_id, srcList[0].src, srcList[0].tag);
    ensureUserInChannel(ch, chanName, call.system_id, srcList[0].src, srcList[0].tag);
  } else if (units.length > 0) {
    srcNick = resolveNick(call.system_id, units[0].unit_id, units[0].alpha_tag);
    ensureUserInChannel(ch, chanName, call.system_id, units[0].unit_id, units[0].alpha_tag);
  }

  // Track active call â€” store src count so call_update can detect new transmissions
  activeCalls.set(call.call_id, {
    tgid: call.tgid, system_id: call.system_id,
    chanName, start: Date.now(),
    srcCount: srcList.length,
  });

  // Show typing indicator for primary speaker
  if (srcNick) showTyping(chanName, srcNick);

  // Emergency handling
  if (call.emergency) {
    addMsg(chanName, {
      ts: ts(), kind: 'notice', emergency: true,
      text: `*** EMERGENCY *** ${srcNick || 'unknown'} â€” emergency call on ${chanName}`,
    });
  }

  // Encrypted call â€” show immediately since we won't get transcript content
  if (call.encrypted) {
    const dur = srcList.length > 0 && srcList[0].duration ? fmtDuration(srcList[0].duration) : '';
    addMsg(chanName, {
      ts: ts(), nick: srcNick || chanName, encrypted: true,
      text: `[encrypted${dur ? ', ' + dur : ''}]`,
    });
    clearTyping(chanName);
  }

  renderTree();
}

/** Ensure a unit is in a channel's nicklist */
function ensureUserInChannel(ch, chanName, systemId, unitId, alphaTag) {
  const uk = unitKey(systemId, unitId);
  if (ch.users.has(uk)) {
    // Mark online if they're transmitting
    const u = ch.users.get(uk);
    if (u.online === false) { u.online = true; if (chanName === activeChannel) renderNicklist(); }
    return;
  }
  const nick = resolveNick(systemId, unitId, alphaTag);
  const role = roleForNick(nick);
  ch.users.set(uk, { nick, prefix: role === 'op' ? '@' : '', role, unitId, systemId, online: true });
  if (chanName === activeChannel) renderNicklist();
}

function handleCallUpdate(call) {
  const tracked = activeCalls.get(call.call_id);
  if (!tracked) return;

  const chanName = tracked.chanName;
  const ch = channels.get(chanName);
  if (!ch) return;

  const srcList = call.src_list || [];
  const systemId = call.system_id || tracked.system_id;

  // Detect new transmissions added since last update
  if (srcList.length > tracked.srcCount) {
    // New key-ups since we last saw this call
    for (let i = tracked.srcCount; i < srcList.length; i++) {
      const tx = srcList[i];
      const nick = resolveNick(systemId, tx.src, tx.tag);
      ensureUserInChannel(ch, chanName, systemId, tx.src, tx.tag);
      showTyping(chanName, nick);
    }
    tracked.srcCount = srcList.length;
  } else if (srcList.length > 0) {
    // No new transmissions, but refresh typing for latest speaker
    const last = srcList[srcList.length - 1];
    showTyping(chanName, resolveNick(systemId, last.src, last.tag));
  }

  // Also pick up any new units from the units array
  const units = call.units || [];
  for (const u of units) {
    ensureUserInChannel(ch, chanName, systemId, u.unit_id, u.alpha_tag);
  }
}

function handleCallEnd(call) {
  const tracked = activeCalls.get(call.call_id);
  activeCalls.delete(call.call_id);

  const chanName = tracked
    ? tracked.chanName
    : resolveChannel(call.system_id, call.tgid);
  if (!chanName) return;

  clearTyping(chanName);

  const ch = channels.get(chanName);
  if (!ch) return;

  const isEmergency = call.emergency || false;

  if (call.encrypted) {
    // Already showed encrypted notice on call_start
    return;
  }

  // Skip if this call was already rendered (e.g. from bootstrap/lazy load)
  const loadedIds = channelLoadedCallIds.get(chanName);
  if (loadedIds && loadedIds.has(call.call_id)) return;

  const srcList = call.src_list || [];
  if (srcList.length > 0) {
    // src_list available â€” render per-unit messages immediately
    renderCallTransmissions(chanName, call.call_id, call.system_id, srcList, isEmergency);
  } else {
    // Render a placeholder message immediately, then try to upgrade with per-unit detail
    const dur = call.duration ? fmtDuration(call.duration) : '';
    const nick = call.tg_alpha_tag || `TG ${call.tgid}`;
    addMsg(chanName, {
      ts: ts(), nick,
      callId: call.call_id,
      duration: dur,
      channel: chanName,
      emergency: isEmergency,
    });
    drainPendingTranscriptions([call.call_id], chanName);

    // Background fetch: if audio handler has already populated src_list, upgrade to per-unit messages
    upgradeCallWithSrcList(call.call_id, chanName, call.system_id, isEmergency);
  }

  // Scanner: enqueue for auto-play if this channel is scanned
  if (call.audio_file_path || (srcList && srcList.length > 0)) {
    const nick = (srcList && srcList.length > 0)
      ? resolveNick(call.system_id, srcList[0].src, srcList[0].tag)
      : (call.tg_alpha_tag || `TG ${call.tgid}`);
    scannerEnqueue(call.call_id, nick, chanName, isEmergency);
  }
}

/** Try to upgrade a fallback call message to per-transmission messages.
 *  If the audio handler has already populated src_list, replace the single
 *  placeholder with one message per key-up. Then fetch and apply transcription
 *  to prevent race condition with handleTranscription. */
async function upgradeCallWithSrcList(callId, chanName, systemId, isEmergency) {
  try {
    const data = await fetchJSON(`/calls/${callId}`);
    const srcList = data.src_list || [];
    if (srcList.length === 0) return; // audio not processed yet â€” keep placeholder

    const ch = channels.get(chanName);
    if (!ch) return;

    // Remove the placeholder message for this call
    const idx = ch.messages.findIndex(m => m.callId === callId);
    if (idx !== -1) ch.messages.splice(idx, 1);

    // Render per-transmission messages in its place
    renderCallTransmissions(chanName, callId, data.system_id || systemId, srcList, data.emergency || isEmergency);

    // Re-render if active (renderCallTransmissions only appends DOM for active channel,
    // but we removed a message so a full re-render is cleaner)
    if (chanName === activeChannel) reRenderChannel(chanName);

    // Always fetch and apply transcription after upgrade â€” this covers the race
    // where handleTranscription applied text to the now-removed placeholder
    try {
      const tx = await fetchJSON(`/calls/${callId}/transcription`);
      if (tx.text) {
        const segments = (tx.words && tx.words.segments) || [];
        applyTranscriptionToChannel(ch, chanName, callId, tx.text, segments);
      }
    } catch (_) {
      // Transcription not available yet â€” handleTranscription SSE will apply it later
    }
  } catch (err) {
    // Fetch failed â€” keep placeholder, transcription will still be applied via SSE/cache
  }
}

/** Render per-transmission voice messages from a call's src_list. */
function renderCallTransmissions(chanName, callId, systemId, srcList, isEmergency) {
  const ch = channels.get(chanName);
  if (!ch) return;

  const sorted = [...srcList].sort((a, b) => (a.pos || 0) - (b.pos || 0));
  for (const tx of sorted) {
    const nick = resolveNick(systemId, tx.src, tx.tag);
    ensureUserInChannel(ch, chanName, systemId, tx.src, tx.tag);

    const txTime = tx.time ? new Date(tx.time * 1000) : new Date();
    const dur = tx.duration ? fmtDuration(tx.duration) : '';
    const txEmergency = tx.emergency === 1;

    addMsg(chanName, {
      ts: ts(txTime), date: txTime,
      nick, src: tx.src,
      pos: tx.pos || 0, txDuration: tx.duration || 0,
      callId,
      duration: dur,
      channel: chanName,
      emergency: isEmergency || txEmergency,
    });
  }

  // Apply any transcriptions that arrived before these messages were rendered
  drainPendingTranscriptions([callId], chanName);
}

function handleUnitEvent(evt) {
  const systemId = evt.system_id;
  const unitId = evt.unit_id;
  const nick = resolveNick(systemId, unitId, evt.unit_alpha_tag);
  const tgid = evt.tgid;

  // Resolve or create channel
  let chanName = tgid ? resolveChannel(systemId, tgid) : null;
  if (!chanName && tgid) {
    chanName = ensureChannel({
      system_id: systemId, tgid,
      alpha_tag: evt.tg_alpha_tag, description: evt.tg_description,
      tag: '', group: 'Ungrouped',
    });
    renderTree();
  }

  switch (evt.event_type) {
    case 'join': {
      // Talkgroup affiliation â†’ IRC JOIN
      if (!chanName) break;
      const ch = channels.get(chanName);
      if (!ch) break;

      const jk = unitKey(systemId, unitId);
      if (!ch.users.has(jk)) {
        const role = roleForNick(nick);
        ch.users.set(jk, { nick, prefix: role === 'op' ? '@' : '', role, unitId, systemId, affiliated: true, online: true });

        addMsg(chanName, {
          ts: ts(), kind: 'join',
          text: `${nick} has joined ${chanName}${ch.tag ? ' [' + ch.tag + ']' : ''}`,
        });
        if (chanName === activeChannel) renderNicklist();
      } else {
        // Mark as affiliated and online
        const u = ch.users.get(jk);
        u.affiliated = true;
        u.online = true;
        if (chanName === activeChannel) renderNicklist();
      }
      break;
    }

    case 'off': {
      // Unit deregistration â†’ mark offline (dimmed in nicklist)
      const ok = unitKey(systemId, unitId);
      let quitChannel = null;
      for (const [chName, ch] of channels) {
        if (ch.users.has(ok)) {
          const u = ch.users.get(ok);
          u.online = false;
          if (!quitChannel) quitChannel = chName; // first channel gets the quit message
          if (chName === activeChannel) renderNicklist();
        }
      }
      if (quitChannel) {
        addMsg(quitChannel, {
          ts: ts(), kind: 'quit',
          text: `${nick} has quit (Quit)`,
        });
      } else {
        serverMsg(`${nick} has disconnected`);
      }
      break;
    }

    case 'on': {
      // Unit registration â†’ mark online in any channels it's in
      const onk = unitKey(systemId, unitId);
      for (const [chName, ch] of channels) {
        if (ch.users.has(onk)) {
          const u = ch.users.get(onk);
          u.online = true;
          if (chName === activeChannel) renderNicklist();
        }
      }
      serverMsg(`${nick} has connected to the network`);
      break;
    }

    case 'call': {
      // Channel grant / voice call â€” show typing
      if (chanName) {
        showTyping(chanName, nick);
        // Temporarily add user to channel if not already present (e.g. patched talkgroup)
        const ck = unitKey(systemId, unitId);
        const ch = channels.get(chanName);
        if (ch && !ch.users.has(ck)) {
          const role = roleForNick(nick);
          ch.users.set(ck, { nick, prefix: role === 'op' ? '@' : '', role, unitId, systemId, affiliated: false, online: true });
          if (chanName === activeChannel) renderNicklist();
        }
      }
      break;
    }

    case 'end': {
      // Per-unit end of transmission â€” remove from channel if not affiliated
      if (chanName) {
        clearTyping(chanName);
        const ek = unitKey(systemId, unitId);
        const ch = channels.get(chanName);
        if (ch) {
          const u = ch.users.get(ek);
          if (u && !u.affiliated) {
            ch.users.delete(ek);
            if (chanName === activeChannel) renderNicklist();
          }
        }
      }
      break;
    }

    case 'location': {
      // Silent â€” could show as CTCP or notice
      break;
    }

    case 'ackresp':
    case 'data':
    case 'ans_req': {
      // Data/signaling â€” silent
      break;
    }

    default:
      break;
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUT HANDLING â€” IRC commands
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.addEventListener('keydown', (e) => {
  if (e.key === '/' && document.activeElement !== inputField) {
    e.preventDefault();
    inputField.focus();
    inputField.value = '/';
  }
});

// Nick tooltip on hover in chat messages (event delegation)
messagesEl.addEventListener('mouseover', (e) => {
  const nickEl = e.target.closest('.nick[data-nick]');
  if (nickEl && nickEl.dataset.nick) showNickTooltip(nickEl.dataset.nick, nickEl);
});
messagesEl.addEventListener('mouseout', (e) => {
  const nickEl = e.target.closest('.nick[data-nick]');
  if (nickEl) hideNickTooltip();
});

inputField.addEventListener('keydown', (e) => {
  if (e.key !== 'Enter') return;
  const val = inputField.value.trim();
  inputField.value = '';
  if (!val) return;

  if (val.startsWith('/')) {
    handleCommand(val);
  } else {
    // Read-only: can't send messages to radio channels
    addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'This client is read-only (Layer 1). Messages cannot be sent.' });
  }
});

function handleCommand(cmd) {
  const parts = cmd.split(/\s+/);
  const c = parts[0].toLowerCase();

  switch (c) {
    case '/j':
    case '/join': {
      const target = parts[1];
      if (!target) { addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Usage: /join #channel' }); break; }
      const raw = target.startsWith('#') ? target.slice(1) : target;
      const match = fuzzyMatchChannel(raw);
      if (match) {
        switchChannel(match);
      } else {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `No such channel: #${raw}` });
      }
      break;
    }

    case '/part':
    case '/leave': {
      switchChannel(STATUS_CHANNEL);
      break;
    }

    case '/list':
    case '/channels': {
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'â€” Channel list â€”' });
      for (const [name, ch] of channels) {
        if (name === STATUS_CHANNEL) continue;
        addMsg(activeChannel, {
          ts: ts(), kind: 'notice',
          text: `  ${name}  (${ch.users.size} users) â€” ${ch.description || ch.alpha_tag}`,
        });
      }
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `â€” End of /list â€” ${channels.size - 1} channels` });
      break;
    }

    case '/who':
    case '/names': {
      const target = parts[1] || activeChannel;
      let ch = channels.get(target);
      if (!ch) {
        // Fuzzy
        for (const [name, c] of channels) {
          if (name.toLowerCase().includes(target.toLowerCase())) { ch = c; break; }
        }
      }
      if (!ch) { addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `No such channel: ${target}` }); break; }
      const nicks = [...ch.users.values()].map(u => `${u.prefix}${u.nick}`).join(' ');
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `[${target}] ${nicks || '(empty)'}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `â€” End of /NAMES â€” ${ch.users.size} total` });
      break;
    }

    case '/topic': {
      const ch = channels.get(activeChannel);
      if (ch) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Topic for ${activeChannel}: ${ch.description || ch.alpha_tag}` });
      }
      break;
    }

    case '/whois': {
      const target = parts[1];
      if (!target) { addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Usage: /whois <nick>' }); break; }
      const lower = target.toLowerCase();
      const onChans = [];
      for (const [name, ch] of channels) {
        for (const u of ch.users.values()) {
          if (u.nick.toLowerCase() === lower) { onChans.push(name); break; }
        }
      }
      if (onChans.length > 0) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `[${target}] is on channels: ${onChans.join(' ')}` });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `[${target}] connected via tr-engine` });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `â€” End of /WHOIS â€”` });
      } else {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `No such nick: ${target}` });
      }
      break;
    }

    case '/fav':
    case '/favorite': {
      if (activeChannel === STATUS_CHANNEL) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Cannot favorite *status' });
        break;
      }
      toggleFavorite(activeChannel);
      addMsg(activeChannel, { ts: ts(), kind: 'notice',
        text: isFavorite(activeChannel)
          ? `Added ${activeChannel} to favorites`
          : `Removed ${activeChannel} from favorites` });
      break;
    }

    case '/scan': {
      if (activeChannel === STATUS_CHANNEL) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Cannot scan *status' });
        break;
      }
      toggleScan(activeChannel);
      addMsg(activeChannel, { ts: ts(), kind: 'notice',
        text: isScanned(activeChannel)
          ? `Added ${activeChannel} to scan list`
          : `Removed ${activeChannel} from scan list` });
      break;
    }
    case '/scanner': {
      scannerEnabled = !scannerEnabled;
      localStorage.setItem('irc_scanner_enabled', scannerEnabled ? '1' : '0');
      updateScannerUI();
      addMsg(activeChannel, { ts: ts(), kind: 'notice',
        text: `Scanner ${scannerEnabled ? 'enabled' : 'disabled'}` });
      break;
    }

    case '/ops': {
      const opArgs = parts.slice(1).join(' ').trim();
      if (!opArgs) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Op patterns: ${getOpPatterns()}` });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Usage: /ops <pattern1>,<pattern2>,... (regex, comma-separated)' });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '/ops reset â€” restore defaults' });
      } else if (opArgs === 'reset') {
        localStorage.removeItem('op_patterns');
        opRegex = buildOpRegex(DEFAULT_OP_PATTERNS);
        reapplyRoles();
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Op patterns reset to: ${DEFAULT_OP_PATTERNS}` });
      } else {
        try {
          const testRe = buildOpRegex(opArgs);
          testRe.test('test'); // validate
          localStorage.setItem('op_patterns', opArgs);
          opRegex = testRe;
          reapplyRoles();
          addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Op patterns set to: ${opArgs}` });
        } catch (e) {
          addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Invalid regex: ${e.message}` });
        }
      }
      break;
    }

    case '/readall':
      markAllRead();
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'All channels marked as read' });
      break;

    case '/clear':
      if (channels.has(activeChannel)) {
        channels.get(activeChannel).messages = [];
        messagesEl.innerHTML = '';
        lastRenderedDateStr = '';
      }
      break;

    case '/reconnect':
      connectSSE();
      break;

    case '/api':
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `API base: ${API_BASE}` });
      break;

    case '/stats': {
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'â€” Stats â€”' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Channels: ${channels.size - 1}` });
      let totalU = 0;
      const uniqueNicks = new Set();
      for (const ch of channels.values()) {
        for (const u of ch.users.values()) uniqueNicks.add(u.nick);
        totalU += ch.users.size;
      }
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Unique users: ${uniqueNicks.size}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Total affiliations: ${totalU}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Active calls: ${activeCalls.size}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Connection: ${connectionState}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'â€” End of /stats â€”' });
      break;
    }

    case '/nerd': {
      const enabled = document.documentElement.classList.toggle('nerd');
      localStorage.setItem('nerd_mode', enabled ? '1' : '0');
      addMsg(activeChannel, { ts: ts(), kind: 'notice',
        text: `Hipster nerd cool mode ${enabled ? 'enabled âœ¨' : 'disabled'}` });
      break;
    }

    case '/help':
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'â€” Commands â€”' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /j, /join #channel  â€” Switch to channel (fuzzy match)' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /part               â€” Switch to *status' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /list               â€” List all channels' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /who, /names        â€” List users in channel' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /whois <nick>       â€” User info' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /topic              â€” Show channel topic' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /stats              â€” Connection & channel stats' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /fav                â€” Toggle favorite on current channel' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /scan               â€” Toggle scanner on current channel' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /scanner            â€” Toggle scanner mode on/off' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /ops [patterns]     â€” View/set op nick patterns (comma-sep regex)' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /readall            â€” Mark all channels as read' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /reconnect          â€” Reconnect SSE stream' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /clear              â€” Clear scrollback' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /api                â€” Show API base URL' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /nerd               â€” Toggle hipster nerd cool mode (small text, low contrast)' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'â€” End of /help â€”' });
      break;

    default:
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Unknown command: ${c}` });
  }
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATUS BAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function updateStatusBar() {
  statusTime.textContent = tsLong();
  statusChannelsEl.textContent = `${channels.size - 1} channels`;

  const now = Date.now();
  eventRate = eventRate.filter(t => now - t < 60000);
  statusRate.textContent = eventRate.length;

  const uniqueNicks = new Set();
  for (const ch of channels.values()) {
    for (const u of ch.users.values()) uniqueNicks.add(u.nick);
  }
  statusUsersEl.textContent = `${uniqueNicks.size} users`;
}


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIO PLAYER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const playerBar = document.getElementById('player-bar');
const playerPlayBtn = document.getElementById('player-play');
const playerNickEl = document.getElementById('player-nick');
const playerChanEl = document.getElementById('player-chan');
const playerTimeEl = document.getElementById('player-time');
const playerProgress = document.getElementById('player-progress');
const playerProgressFill = document.getElementById('player-progress-fill');
const playerCloseBtn = document.getElementById('player-close');

const audioEl = new Audio();
audioEl.preload = 'auto';
let currentPlayingMsgEl = null;
let currentCallId = null;
let playerRaf = null;

function fmtAudioTime(sec) {
  if (!sec || !isFinite(sec)) return '0:00';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

function playCall(callId, nick, channel, msgEl) {
  // If clicking the same call that's playing, toggle pause
  if (currentCallId === callId && !audioEl.paused) {
    audioEl.pause();
    playerPlayBtn.textContent = 'â–¶';
    return;
  }
  if (currentCallId === callId && audioEl.paused) {
    audioEl.play().then(() => {
      playerPlayBtn.textContent = 'â¸';
      updatePlayerProgress();
    }).catch(() => { playerPlayBtn.textContent = 'â–¶'; });
    return;
  }

  // New call â€” load and play
  currentCallId = callId;

  // Clear previous highlight
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = msgEl;
  if (msgEl) msgEl.classList.add('now-playing');

  // Update player bar
  playerNickEl.textContent = nick || '?';
  playerNickEl.style.color = nickColor(nick || '');
  playerChanEl.textContent = channel || '';
  playerTimeEl.textContent = '0:00 / --:--';
  playerProgressFill.style.width = '0%';
  playerBar.classList.add('active');
  playerPlayBtn.textContent = 'â³';

  // Load audio
  const audioUrl = `${API_BASE}/calls/${callId}/audio`;
  audioEl.src = audioUrl;
  audioEl.load();
  audioEl.play().then(() => {
    playerPlayBtn.textContent = 'â¸';
    updatePlayerProgress();
  }).catch(err => {
    playerPlayBtn.textContent = 'â–¶';
    playerTimeEl.textContent = err.name === 'NotAllowedError' ? 'click to play' : 'no audio';
    console.warn('Playback error:', err.message);
  });
}

function updatePlayerProgress() {
  if (playerRaf) cancelAnimationFrame(playerRaf);

  function tick() {
    if (!audioEl.paused && audioEl.duration) {
      const pct = (audioEl.currentTime / audioEl.duration) * 100;
      playerProgressFill.style.width = pct + '%';
      playerTimeEl.textContent = `${fmtAudioTime(audioEl.currentTime)} / ${fmtAudioTime(audioEl.duration)}`;
    }
    if (!audioEl.paused) playerRaf = requestAnimationFrame(tick);
  }
  tick();
}

// Play/pause button
playerPlayBtn.addEventListener('click', () => {
  if (!audioEl.src) return;
  if (audioEl.paused) {
    audioEl.play().then(() => {
      playerPlayBtn.textContent = 'â¸';
      updatePlayerProgress();
    }).catch(() => { playerPlayBtn.textContent = 'â–¶'; });
  } else {
    audioEl.pause();
    playerPlayBtn.textContent = 'â–¶';
  }
});

// Close player
playerCloseBtn.addEventListener('click', () => {
  audioEl.pause();
  audioEl.src = '';
  currentCallId = null;
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = null;
  playerBar.classList.remove('active');
  if (playerRaf) cancelAnimationFrame(playerRaf);
  // Reset scanner state so queue can resume on next enqueue
  scannerPlaying = false;
  updateScannerQueueUI();
});

// Skip button â€” advance to next scanner item
document.getElementById('player-skip').addEventListener('click', () => {
  audioEl.pause();
  audioEl.src = '';
  playerPlayBtn.textContent = '\u25B6';
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = null;
  currentCallId = null;
  if (scannerEnabled && scannerQueue.length > 0) {
    setTimeout(scannerPlayNext, 300);
  } else {
    scannerPlaying = false;
    updateScannerQueueUI();
  }
});

// Seek on progress bar click
playerProgress.addEventListener('click', (e) => {
  if (!audioEl.duration) return;
  const rect = playerProgress.getBoundingClientRect();
  const pct = (e.clientX - rect.left) / rect.width;
  audioEl.currentTime = pct * audioEl.duration;
  playerProgressFill.style.width = (pct * 100) + '%';
});

// Audio ended
audioEl.addEventListener('ended', () => {
  playerPlayBtn.textContent = 'â–¶';
  playerProgressFill.style.width = '100%';
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = null;
  currentCallId = null;

  // Scanner: play next in queue
  if (scannerEnabled && scannerQueue.length > 0) {
    setTimeout(scannerPlayNext, 300); // small gap between transmissions
  } else {
    scannerPlaying = false;
    updateScannerQueueUI();
  }
});

// Audio error â€” skip failed audio so scanner doesn't stall
audioEl.addEventListener('error', () => {
  playerPlayBtn.textContent = '\u25B6';
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = null;
  currentCallId = null;
  if (scannerEnabled && scannerQueue.length > 0) {
    setTimeout(scannerPlayNext, 300);
  } else {
    scannerPlaying = false;
    updateScannerQueueUI();
  }
});

// Duration loaded
audioEl.addEventListener('loadedmetadata', () => {
  playerTimeEl.textContent = `0:00 / ${fmtAudioTime(audioEl.duration)}`;
});


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// READ ALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function markAllRead() {
  for (const key of channelUnread.keys()) {
    channelUnread.set(key, 0);
  }
  renderTree();
}

document.getElementById('read-all-btn').addEventListener('click', markAllRead);

// â”€â”€ Nerd mode: restore from localStorage â”€â”€
if (localStorage.getItem('nerd_mode') === '1') {
  document.documentElement.classList.add('nerd');
}
document.getElementById('nerd-btn').addEventListener('click', () => {
  const enabled = document.documentElement.classList.toggle('nerd');
  localStorage.setItem('nerd_mode', enabled ? '1' : '0');
});

// â”€â”€ Scanner toggle â”€â”€
const scannerBtn = document.getElementById('scanner-btn');
const scannerQueueInfo = document.getElementById('scanner-queue-info');

function updateScannerUI() {
  scannerBtn.classList.toggle('active', scannerEnabled);
}

scannerBtn.addEventListener('click', () => {
  scannerEnabled = !scannerEnabled;
  localStorage.setItem('irc_scanner_enabled', scannerEnabled ? '1' : '0');
  updateScannerUI();
  if (!scannerEnabled) {
    scannerQueue.length = 0;
    scannerQueueInfo.textContent = '';
  }
});

updateScannerUI();


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOBILE DRAWERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const channelTree = document.querySelector('.channel-tree');
const nicklist = document.querySelector('.nicklist');
const drawerBackdrop = document.getElementById('drawer-backdrop');
const hamburgerBtn = document.getElementById('mobile-hamburger');
const usersBtn = document.getElementById('mobile-users-btn');

function openDrawer(which) {
  if (which === 'channels') {
    channelTree.classList.add('open');
    nicklist.classList.remove('open');
  } else {
    nicklist.classList.add('open');
    channelTree.classList.remove('open');
  }
  drawerBackdrop.classList.add('visible');
}

function closeDrawers() {
  channelTree.classList.remove('open');
  nicklist.classList.remove('open');
  drawerBackdrop.classList.remove('visible');
}

hamburgerBtn.addEventListener('click', () => openDrawer('channels'));
usersBtn.addEventListener('click', () => openDrawer('users'));
drawerBackdrop.addEventListener('click', closeDrawers);

// Swipe gestures for mobile drawers
let touchStartX = 0;
let touchStartY = 0;
const SWIPE_THRESHOLD = 50;
const EDGE_ZONE = 30; // pixels from screen edge

document.addEventListener('touchstart', (e) => {
  touchStartX = e.touches[0].clientX;
  touchStartY = e.touches[0].clientY;
}, { passive: true });

document.addEventListener('touchend', (e) => {
  const dx = e.changedTouches[0].clientX - touchStartX;
  const dy = e.changedTouches[0].clientY - touchStartY;

  // Only trigger on horizontal swipes (not vertical scroll)
  if (Math.abs(dx) < SWIPE_THRESHOLD || Math.abs(dy) > Math.abs(dx)) return;
  if (window.innerWidth > 768) return;

  if (dx > 0 && touchStartX < EDGE_ZONE) {
    // Swipe right from left edge â€” open channels
    openDrawer('channels');
  } else if (dx < 0 && touchStartX > window.innerWidth - EDGE_ZONE) {
    // Swipe left from right edge â€” open users
    openDrawer('users');
  } else if (dx < 0 && channelTree.classList.contains('open')) {
    closeDrawers();
  } else if (dx > 0 && nicklist.classList.contains('open')) {
    closeDrawers();
  }
}, { passive: true });


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function init() {
  initStatusChannel();
  switchChannel(STATUS_CHANNEL);
  renderTree();

  serverMsg(`tr-engine IRC client â€” Layer 1 (read-only)`);
  serverMsg(`API: ${API_BASE}`);
  serverMsg('');

  // Bootstrap: channels â†’ affiliations â†’ recent calls â†’ SSE
  await bootstrapChannels();
  await bootstrapAffiliations();
  await bootstrapRecentCalls();

  // Connect SSE for live events
  connectSSE();

  // Status bar ticker
  setInterval(updateStatusBar, 1000);
  updateStatusBar();
}

init();
inputField.focus();
</script>
<div class="vignette-overlay"></div>
<div class="theme-label" id="themeLabel"></div>
<script src="theme-engine.js"></script>
</body>
</html>
