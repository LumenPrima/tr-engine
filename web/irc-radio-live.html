<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>tr-engine IRC</title>
<meta name="card-title" content="IRC Radio">
<meta name="card-description" content="IRC-style live radio monitor with channels, nicks, and audio playback">
<meta name="card-order" content="0">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Iosevka:wght@400;500&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #000000;
  --bg-panel: #0a0a0a;
  --bg-input: #000000;
  --bg-highlight: #1a1a1a;
  --bg-hover: #151515;
  --border: #444444;
  --border-light: #555555;
  --text: #f0f0f0;
  --text-dim: #bbbbbb;
  --text-muted: #999999;
  --text-bright: #ffffff;
  --white: #ffffff;
  --nick-cyan: #5ce0d8;
  --nick-green: #78c06a;
  --nick-orange: #d4944a;
  --nick-magenta: #c06abc;
  --nick-yellow: #c4b44e;
  --nick-blue: #5a9ec0;
  --nick-red: #c65454;
  --nick-teal: #4aafa0;
  --nick-pink: #d080a0;
  --nick-lime: #90c050;
  --join: #55cc55;
  --part: #cc5555;
  --action: #7a5aa0;
  --notice: #aabbdd;
  --emergency: #e03030;
  --emergency-bg: rgba(224, 48, 48, 0.08);
  --encrypted-bg: rgba(200, 160, 40, 0.06);
  --chan-active: #ffffff;
  --chan-inactive: #bbbbbb;
  --chan-highlight: #d4944a;
  --status-connected: #4a8a4a;
  --status-disconnected: #8a4a4a;
  --status-connecting: #8a8a4a;
  --timestamp: #888888;
}

html, body { height: 100%; overflow: hidden; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'IBM Plex Mono', 'Courier New', monospace;
  font-size: 16px;
  line-height: 1.45;
  display: flex;
  flex-direction: column;
}

/* ── Top bar ── */
.titlebar {
  height: 28px;
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  font-size: 14px;
  color: var(--text-dim);
  gap: 8px;
  flex-shrink: 0;
  user-select: none;
}
.titlebar .server { color: var(--nick-cyan); font-weight: 500; }
.titlebar .topic { color: var(--text-muted); margin-left: 8px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.titlebar .lag { color: var(--status-connecting); margin-left: auto; }

/* ── Main layout ── */
.main { display: flex; flex: 1; overflow: hidden; }

/* ── Channel tree (left panel) ── */
.channel-tree {
  width: 240px;
  min-width: 240px;
  background: var(--bg-panel);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  user-select: none;
}
.tree-header-row {
  padding: 6px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--border);
}
.tree-header-text {
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text-muted);
}
.read-all-btn {
  background: none;
  border: 1px solid var(--border-light);
  color: var(--text-dim);
  font-family: inherit;
  font-size: 12px;
  padding: 1px 6px;
  border-radius: 3px;
  cursor: pointer;
  transition: color 0.15s, border-color 0.15s;
}
.read-all-btn:hover { color: var(--nick-cyan); border-color: var(--nick-cyan); }
.tree-more {
  padding: 2px 12px 2px 20px;
  font-size: 13px;
  font-style: italic;
  color: var(--text-muted);
  cursor: pointer;
  transition: color 0.15s;
}
.tree-more:hover { color: var(--text-dim); }
.tree-scroll {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}
.tree-scroll::-webkit-scrollbar { width: 6px; }
.tree-scroll::-webkit-scrollbar-track { background: transparent; }
.tree-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.tree-section { padding: 4px 0; }
.tree-section-label {
  padding: 3px 12px;
  font-size: 13px;
  color: var(--text-muted);
  letter-spacing: 0.06em;
  cursor: pointer;
}
.tree-section-label .nb { white-space: nowrap; }
.tree-section-label:hover { color: var(--text-dim); }
.tree-section-label::before { content: '▾ '; font-size: 11px; }
.tree-section-label.collapsed::before { content: '▸ '; }

.channel-item {
  padding: 2px 12px 2px 20px;
  cursor: pointer;
  color: var(--chan-inactive);
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
  overflow: hidden;
}
.channel-item:hover { background: var(--bg-hover); color: var(--text); }
.channel-item.active { color: var(--chan-active); background: var(--bg-highlight); font-weight: 500; }
.channel-item.has-activity { color: var(--chan-highlight); }
.channel-item .chan-prefix { color: var(--text-muted); }
.channel-item .chan-label { overflow: hidden; text-overflow: ellipsis; }
.channel-item .unread {
  margin-left: auto; font-size: 12px; color: var(--bg);
  background: var(--chan-highlight); border-radius: 3px;
  padding: 0 4px; min-width: 14px; text-align: center; font-weight: 600;
  flex-shrink: 0;
}

.tree-status {
  padding: 8px 12px;
  border-top: 1px solid var(--border);
  font-size: 13px;
  color: var(--text-muted);
  flex-shrink: 0;
}
.tree-status .dot {
  display: inline-block; width: 6px; height: 6px;
  border-radius: 50%; margin-right: 4px; vertical-align: middle;
}
.tree-status .dot.connected { background: var(--status-connected); }
.tree-status .dot.disconnected { background: var(--status-disconnected); }
.tree-status .dot.connecting { background: var(--status-connecting); animation: blink 1s infinite; }
@keyframes blink { 50% { opacity: 0.3; } }

/* ── Chat area ── */
.chat-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; min-width: 0; }

.channel-bar {
  height: 32px;
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 14px;
  gap: 10px;
  flex-shrink: 0;
}
.channel-bar .chan-name { font-weight: 600; font-size: 16px; color: var(--white); }
.channel-bar .chan-topic { font-size: 14px; color: var(--text-dim); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
.channel-bar .chan-mode { font-size: 13px; color: var(--text-muted); }
.channel-bar .chan-count { font-size: 13px; color: var(--text-dim); margin-left: auto; white-space: nowrap; }

/* ── Messages ── */
.messages {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 4px 0;
}
.messages::-webkit-scrollbar { width: 8px; }
.messages::-webkit-scrollbar-track { background: transparent; }
.messages::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
.messages::-webkit-scrollbar-thumb:hover { background: var(--border-light); }

.msg {
  padding: 1px 14px;
  display: flex;
  gap: 0;
  min-height: 19px;
  align-items: baseline;
}
.msg:hover { background: var(--bg-hover); }
.msg .ts { color: var(--timestamp); font-size: 14px; min-width: 82px; flex-shrink: 0; user-select: none; }
.date-separator {
  text-align: center;
  font-size: 13px;
  color: var(--text-muted);
  padding: 6px 14px 4px;
  position: relative;
}
.date-separator::before, .date-separator::after {
  content: '';
  position: absolute;
  top: 50%;
  height: 1px;
  background: var(--border);
  width: calc(50% - 80px);
}
.date-separator::before { left: 14px; }
.date-separator::after { right: 14px; }
.msg .nick {
  font-weight: 500; min-width: 130px; max-width: 130px; text-align: right;
  padding-right: 8px; flex-shrink: 0;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.msg .nick::before { content: '<'; color: var(--text-muted); }
.msg .nick::after { content: '>'; color: var(--text-muted); }
.msg .body { flex: 1; word-break: break-word; min-width: 0; }

.msg.system .nick { min-width: 0; max-width: none; padding-right: 0; }
.msg.system .nick::before, .msg.system .nick::after { display: none; }
.msg.system .prefix { color: var(--text-muted); margin-right: 0; }
.msg.system .body { font-size: 15px; }

.msg.join .body { color: var(--join); }
.msg.part .body, .msg.quit .body { color: var(--part); }
.msg.mode .body { color: var(--notice); }
.msg.action .body { color: var(--action); font-style: italic; }
.msg.notice .body { color: var(--notice); }
.msg.topic .body { color: var(--notice); }

.msg.emergency { background: var(--emergency-bg); }
.msg.emergency .body { color: var(--emergency); font-weight: 600; }
.msg.emergency .nick { color: var(--emergency) !important; }

.msg.encrypted { background: var(--encrypted-bg); }
.msg.encrypted .body { color: var(--nick-yellow); font-style: italic; }

/* ── Call grouping — visual bracket for multi-transmission calls ── */
.msg.call-group-first,
.msg.call-group-mid,
.msg.call-group-last { position: relative; padding-top: 0; padding-bottom: 0; min-height: 18px; }
.msg.call-group-first::before,
.msg.call-group-mid::before,
.msg.call-group-last::before {
  content: ''; position: absolute; left: 70px; top: 0; bottom: 0;
  border-left: 2px solid var(--border-light);
}
.msg.call-group-first::before { top: 50%; }
.msg.call-group-last::before { bottom: 50%; }
.msg.call-group-mid .ts, .msg.call-group-last .ts { visibility: hidden; }

/* ── Typing bar ── */
.typing-bar {
  min-height: 20px;
  padding: 2px 14px;
  font-size: 14px;
  color: var(--text-muted);
  border-top: 1px solid var(--border);
  background: var(--bg);
  flex-shrink: 0;
}
.typing-bar .typing-nick { color: var(--nick-cyan); }

/* ── Audio player bar ── */
.player-bar {
  display: none;
  border-top: 1px solid var(--border);
  background: var(--bg-panel);
  flex-shrink: 0;
  padding: 4px 14px;
}
.player-bar.active { display: block; }
.player-inner {
  display: flex;
  align-items: center;
  gap: 10px;
}
.player-btn {
  background: none;
  border: 1px solid var(--border-light);
  color: var(--nick-cyan);
  font-size: 14px;
  width: 26px;
  height: 22px;
  border-radius: 3px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
  font-family: inherit;
  transition: border-color 0.15s, color 0.15s;
}
.player-btn:hover { border-color: var(--nick-cyan); color: var(--white); }
.player-btn.player-close { color: var(--text-dim); font-size: 13px; width: 22px; }
.player-btn.player-close:hover { color: var(--nick-red); border-color: var(--nick-red); }
.player-info {
  display: flex;
  gap: 8px;
  align-items: center;
  font-size: 14px;
  min-width: 0;
  flex-shrink: 0;
}
.player-nick { color: var(--nick-cyan); font-weight: 500; }
.player-chan { color: var(--text-muted); }
.player-time { color: var(--text-dim); font-size: 13px; font-variant-numeric: tabular-nums; }
.player-progress {
  flex: 1;
  height: 4px;
  background: var(--border);
  border-radius: 2px;
  cursor: pointer;
  position: relative;
  min-width: 60px;
}
.player-progress-fill {
  height: 100%;
  background: var(--nick-cyan);
  border-radius: 2px;
  width: 0%;
  transition: width 0.1s linear;
}
.player-progress:hover .player-progress-fill { background: var(--white); }

/* ── Voice message links ── */
.voice-play { color: var(--nick-cyan); font-size: 15px; margin-right: 2px; }
.voice-dur { color: var(--text); }
.voice-listen {
  color: var(--text-dim);
  cursor: pointer;
  text-decoration: none;
  border-bottom: 1px dotted var(--text-muted);
  margin-left: 4px;
  transition: color 0.15s;
}
.voice-listen:hover { color: var(--nick-cyan); border-bottom-color: var(--nick-cyan); }
.msg.now-playing { background: rgba(92, 224, 216, 0.04); }
.msg.now-playing .voice-listen { color: var(--nick-cyan); border-bottom-color: var(--nick-cyan); }

/* ── Input ── */
.input-area {
  display: flex;
  align-items: center;
  border-top: 1px solid var(--border);
  background: var(--bg-input);
  flex-shrink: 0;
}
.input-prompt {
  padding: 0 4px 0 14px;
  color: var(--text-dim);
  font-size: 15px;
  user-select: none;
  white-space: nowrap;
}
.input-field {
  flex: 1;
  background: none;
  border: none;
  outline: none;
  color: var(--text-bright);
  font-family: inherit;
  font-size: 16px;
  padding: 8px 8px;
  caret-color: var(--nick-cyan);
}
.input-field::placeholder { color: var(--text-muted); }

/* ── Nicklist ── */
.nicklist {
  width: 164px;
  min-width: 164px;
  background: var(--bg-panel);
  border-left: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  user-select: none;
}
.nicklist-header {
  padding: 8px 10px;
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
  border-bottom: 1px solid var(--border);
}
.nicklist-section-label {
  padding: 4px 10px 2px;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-muted);
}
.nicklist-entries {
  overflow-y: auto;
  flex: 1;
}
.nicklist-entries::-webkit-scrollbar { width: 6px; }
.nicklist-entries::-webkit-scrollbar-track { background: transparent; }
.nicklist-entries::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

.nick-item {
  padding: 1px 10px;
  font-size: 14px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  cursor: default;
}
.nick-item:hover { background: var(--bg-hover); }
.nick-item .nick-prefix { color: var(--text-muted); font-size: 13px; margin-right: 2px; }
.nick-item.op { color: var(--nick-cyan); }
.nick-item.voice { color: var(--nick-green); }
.nick-item.regular { color: var(--text-dim); }
.nick-item.offline { opacity: 0.35; }
.nick-item.talked::after { content: '●'; color: var(--nick-green); font-size: 10px; margin-left: 4px; vertical-align: middle; }

/* ── Nick tooltip ── */
.nick-tooltip {
  display: none; position: fixed; z-index: 100;
  background: #1a1a2e; border: 1px solid var(--border-light); border-radius: 4px;
  padding: 6px 10px; font-size: 14px; line-height: 1.5;
  color: var(--text-dim); pointer-events: none;
  max-width: 260px; white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0,0,0,0.4);
}
.nick-tooltip .tt-nick { color: var(--nick-cyan); font-weight: 600; }
.nick-tooltip .tt-label { color: var(--text-muted); }
.nick-tooltip .tt-online { color: var(--nick-green); }
.nick-tooltip .tt-offline { color: #888; }
.msg .nick { cursor: default; }
.nick-item { cursor: default; }

/* ── Status bar ── */
.statusbar {
  height: 22px;
  background: var(--bg-panel);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  padding: 0 12px;
  font-size: 13px;
  color: var(--text-muted);
  gap: 16px;
  flex-shrink: 0;
  user-select: none;
}
.statusbar .sep { color: var(--border-light); }
.statusbar .status-highlight { color: var(--nick-orange); }
.statusbar .status-ok { color: var(--status-connected); }
.statusbar .status-err { color: var(--status-disconnected); }
.statusbar .nerd-btn {
  background: none;
  border: 1px solid var(--border-light);
  color: var(--text-muted);
  font-family: inherit;
  font-size: 12px;
  padding: 0 4px;
  border-radius: 2px;
  cursor: pointer;
  line-height: 16px;
  margin-left: auto;
  transition: color 0.15s, border-color 0.15s;
}
.statusbar .nerd-btn:hover { color: var(--nick-cyan); border-color: var(--nick-cyan); }
html.nerd .statusbar .nerd-btn { color: var(--nick-magenta); border-color: var(--nick-magenta); }

/* ── Hipster nerd cool mode — low-contrast, tiny text ── */
html.nerd {
  --bg: #0a0a12;
  --bg-panel: #0e0e1a;
  --bg-input: #08080f;
  --bg-highlight: #141425;
  --bg-hover: #12121f;
  --border: #1a1a2e;
  --border-light: #2e2e4a;
  --text: #c8c8d4;
  --text-dim: #7a7a96;
  --text-muted: #555570;
  --text-bright: #e8e8f0;
  --white: #f0f0f8;
  --chan-active: #e8e8f0;
  --chan-inactive: #80809a;
  --timestamp: #3a3a52;
  --notice: #5a6a8a;
  --join: #3a7a3a;
  --part: #6a4040;
}
html.nerd body { font-size: 13px; }
html.nerd .titlebar { font-size: 11px; }
html.nerd .tree-header-text { font-size: 10px; }
html.nerd .read-all-btn { font-size: 9px; }
html.nerd .tree-more { font-size: 10px; }
html.nerd .tree-section-label { font-size: 10px; }
html.nerd .tree-section-label::before { font-size: 8px; }
html.nerd .channel-item { font-size: 11px; }
html.nerd .channel-item .unread { font-size: 9px; }
html.nerd .tree-status { font-size: 10px; }
html.nerd .channel-bar .chan-name { font-size: 13px; }
html.nerd .channel-bar .chan-topic { font-size: 11px; }
html.nerd .channel-bar .chan-mode { font-size: 10px; }
html.nerd .channel-bar .chan-count { font-size: 10px; }
html.nerd .msg .ts { font-size: 11px; }
html.nerd .date-separator { font-size: 10px; }
html.nerd .msg.system .body { font-size: 12px; }
html.nerd .typing-bar { font-size: 11px; }
html.nerd .player-btn { font-size: 11px; }
html.nerd .player-btn.player-close { font-size: 10px; }
html.nerd .player-info { font-size: 11px; }
html.nerd .player-time { font-size: 10px; }
html.nerd .voice-play { font-size: 12px; }
html.nerd .input-prompt { font-size: 12px; }
html.nerd .input-field { font-size: 13px; }
html.nerd .nicklist-header { font-size: 10px; }
html.nerd .nicklist-section-label { font-size: 9px; }
html.nerd .nick-item { font-size: 11px; }
html.nerd .nick-item .nick-prefix { font-size: 10px; }
html.nerd .nick-item.talked::after { font-size: 7px; }
html.nerd .nick-tooltip { font-size: 11px; }
html.nerd .statusbar { font-size: 10px; }
html.nerd .statusbar .nerd-btn { font-size: 9px; }
</style>
</head>
<body>

<div class="titlebar">
  <span class="server">tr-engine</span>
  <span>—</span>
  <span id="titlebar-chan">*status</span>
  <span class="topic" id="titlebar-topic">Connecting...</span>
  <span class="lag" id="titlebar-lag"></span>
</div>

<div class="main">
  <div class="channel-tree">
    <div class="tree-header-row">
      <span class="tree-header-text">tr-engine</span>
      <button class="read-all-btn" id="read-all-btn">Read All</button>
    </div>
    <div class="tree-scroll" id="tree-scroll"></div>
    <div class="tree-status" id="tree-status">
      <span class="dot connecting"></span>Connecting...
    </div>
  </div>

  <div class="chat-area">
    <div class="channel-bar">
      <span class="chan-name" id="chan-name">*status</span>
      <span class="chan-mode" id="chan-mode"></span>
      <span class="chan-topic" id="chan-topic">Connecting to tr-engine...</span>
      <span class="chan-count" id="chan-count"></span>
    </div>
    <div class="messages" id="messages"></div>
    <div class="typing-bar" id="typing-bar"></div>
    <div class="player-bar" id="player-bar">
      <div class="player-inner">
        <button class="player-btn" id="player-play" title="Play/Pause">▶</button>
        <div class="player-info">
          <span class="player-nick" id="player-nick"></span>
          <span class="player-chan" id="player-chan"></span>
          <span class="player-time" id="player-time">0:00 / 0:00</span>
        </div>
        <div class="player-progress" id="player-progress">
          <div class="player-progress-fill" id="player-progress-fill"></div>
        </div>
        <button class="player-btn player-close" id="player-close" title="Close">✕</button>
      </div>
    </div>
    <div class="input-area">
      <div class="input-prompt" id="input-prompt">[*status]</div>
      <input class="input-field" id="input-field" type="text" placeholder="Type /help for commands" spellcheck="false" autocomplete="off">
    </div>
  </div>

  <div class="nicklist">
    <div class="nicklist-header" id="nicklist-header">Users</div>
    <div class="nicklist-entries" id="nicklist-entries"></div>
  </div>
</div>

<div class="statusbar">
  <span class="status-ok" id="status-dot">●</span>
  <span id="status-server">tr-engine</span>
  <span class="sep">│</span>
  <span id="status-channels">0 channels</span>
  <span class="sep">│</span>
  <span id="status-users">0 users</span>
  <span class="sep">│</span>
  <span>Events: <span class="status-highlight" id="status-rate">0</span>/min</span>
  <span class="sep">│</span>
  <span id="status-time"></span>
  <button class="nerd-btn" id="nerd-btn" title="Toggle hipster nerd cool mode">nerd</button>
</div>
<div class="nick-tooltip" id="nick-tooltip"></div>

<script>
// ══════════════════════════════════════════════════════════════
// TODO — Enhancement ideas
// ══════════════════════════════════════════════════════════════
// [ ] Favorite/pinned channels — star channels to pin at top of tree (localStorage)
// [ ] Channel search box — filter input at top of tree for instant name filtering
// [ ] Emergency flash in tree — pulse channel name red on emergency calls
// [ ] Scanner mode — toggle to auto-play audio as transmissions arrive
// [ ] Keyboard channel nav — Alt+Up/Down to cycle channels with activity
// [ ] Transmission count on nicks — show count next to dot (e.g. "●12")
// [ ] Desktop notifications — browser notifications for backgrounded tab activity
// [x] Unit info on hover — tooltip with system, unit ID, status, last TX time
// ══════════════════════════════════════════════════════════════

// ══════════════════════════════════════════════════════════════
// CONFIG — set your tr-engine base URL
// Override via query param: ?api=http://localhost:3000/api/v1
// ══════════════════════════════════════════════════════════════
const params = new URLSearchParams(location.search);
const API_BASE = (params.get('api') || '/api/v1').replace(/\/+$/, '');

const MAX_MESSAGES = 500;        // per channel scrollback
const NICK_WIDTH = 130;          // px
const TYPING_DURATION = 3000;    // ms

// ── Op patterns: comma-separated regexes matched against unit nicks ──
// Units matching any pattern get @ (op) status in the nicklist.
// Edit here or use /ops at runtime. Stored in localStorage.
const DEFAULT_OP_PATTERNS = 'LocutionLCD,\\dCOM,CHF,CAPT,BATT,Desk';

// ── Nick color palette ──
const NICK_COLORS = [
  'var(--nick-cyan)', 'var(--nick-green)', 'var(--nick-orange)',
  'var(--nick-magenta)', 'var(--nick-yellow)', 'var(--nick-blue)',
  'var(--nick-red)', 'var(--nick-teal)', 'var(--nick-pink)', 'var(--nick-lime)',
];
function nickColor(nick) {
  let h = 0;
  for (let i = 0; i < nick.length; i++) h = ((h << 5) - h + nick.charCodeAt(i)) | 0;
  return NICK_COLORS[Math.abs(h) % NICK_COLORS.length];
}

// ══════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════

// Channel registry: keyed by IRC-style name (#alpha-tag)
// { chanName: { tgid, system_id, alpha_tag, description, tag, group, mode, users: Map<unit_id, {nick, prefix, role}>, messages: [] } }
const channels = new Map();
const channelUnread = new Map();

// Reverse lookups
const tgidToChannel = new Map();   // `${system_id}:${tgid}` → chanName
const unitNickCache = new Map();   // `${system_id}:${unit_id}` → alpha_tag
const systemNames = new Map();     // system_id → system_name

// Active channel
let activeChannel = '*status';

// Status channel for server messages
const STATUS_CHANNEL = '*status';

// Connection state
let sseConnection = null;
let connectionState = 'disconnected'; // connecting, connected, disconnected
let reconnectTimer = null;
let lastEventId = null;
let eventRate = [];

// Typing state: Map<chanName, { nick, timeout }>
const typingState = new Map();

// Active calls tracker: Map<call_id, { tgid, system_id, units, start }>
const activeCalls = new Map();

// Activity tracking for channel tree collapse
const channelHasActivity = new Set();   // channels with real messages
const groupCollapsed = new Map();       // group collapse state (true = show all, false = collapsed)
const channelLoading = new Set();       // prevent duplicate lazy-loads
const channelLoadedCallIds = new Map(); // chanName -> Set<callId> — deduplicate across bootstrap and lazy load

// ── DOM refs ──
const messagesEl = document.getElementById('messages');
const typingBar = document.getElementById('typing-bar');
const inputField = document.getElementById('input-field');
const chanNameEl = document.getElementById('chan-name');
const chanTopicEl = document.getElementById('chan-topic');
const chanModeEl = document.getElementById('chan-mode');
const chanCountEl = document.getElementById('chan-count');
const nicklistHeader = document.getElementById('nicklist-header');
const nicklistEntries = document.getElementById('nicklist-entries');
const titlebarChan = document.getElementById('titlebar-chan');
const titlebarTopic = document.getElementById('titlebar-topic');
const titlebarLag = document.getElementById('titlebar-lag');
const treeScroll = document.getElementById('tree-scroll');
const treeStatus = document.getElementById('tree-status');
const statusDot = document.getElementById('status-dot');
const statusServer = document.getElementById('status-server');
const statusChannelsEl = document.getElementById('status-channels');
const statusUsersEl = document.getElementById('status-users');
const statusRate = document.getElementById('status-rate');
const statusTime = document.getElementById('status-time');
const inputPrompt = document.getElementById('input-prompt');


// ══════════════════════════════════════════════════════════════
// HELPERS
// ══════════════════════════════════════════════════════════════

function ts(date) {
  const d = date || new Date();
  const time = d.toTimeString().slice(0, 5);
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const msgDay = new Date(d.getFullYear(), d.getMonth(), d.getDate());
  if (msgDay.getTime() >= todayStart.getTime()) return time;
  const m = d.getMonth() + 1;
  const day = d.getDate();
  return `${m}/${day} ${time}`;
}

function tsLong(date) {
  const d = date || new Date();
  return d.toTimeString().slice(0, 8);
}

const MONTHS_SHORT = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const DAYS_LONG = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];

function formatDateSeparator(date) {
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const msgDay = new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const diff = Math.round((todayStart - msgDay) / 86400000);
  if (diff === 0) return 'Today';
  if (diff === 1) return 'Yesterday';
  if (diff < 7) return DAYS_LONG[date.getDay()];
  return `${DAYS_LONG[date.getDay()]}, ${MONTHS_SHORT[date.getMonth()]} ${date.getDate()}`;
}

let lastRenderedDateStr = '';

/** Convert a talkgroup alpha_tag to an IRC channel name */
function toChannelName(alphaTag) {
  if (!alphaTag) return '#unknown';
  // Replace spaces and special chars with hyphens, collapse runs
  let name = alphaTag.replace(/[\s\/\\]+/g, '-').replace(/[^a-zA-Z0-9\-_.]/g, '').replace(/-+/g, '-').replace(/^-|-$/g, '');
  return '#' + (name || 'unknown');
}

/** Sanitize a unit alpha_tag into an IRC nick */
function toNick(alphaTag, unitId) {
  if (alphaTag && alphaTag.trim()) {
    return alphaTag.trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_\-\[\]{}|]/g, '');
  }
  return 'unit-' + unitId;
}

/** Determine user role from nick/alpha_tag */
function getOpPatterns() { return localStorage.getItem('op_patterns') || DEFAULT_OP_PATTERNS; }
function buildOpRegex(csv) { return new RegExp(csv.split(',').map(s => s.trim()).filter(Boolean).join('|'), 'i'); }
let opRegex = buildOpRegex(getOpPatterns());
function roleForNick(nick) {
  if (!nick) return 'regular';
  return opRegex.test(nick) ? 'op' : 'regular';
}
function reapplyRoles() {
  for (const ch of channels.values()) {
    for (const u of ch.users.values()) {
      u.role = roleForNick(u.nick);
      u.prefix = u.role === 'op' ? '@' : '';
    }
  }
  renderNicklist();
}

/** Nick tooltip */
const nickTooltip = document.getElementById('nick-tooltip');
let tooltipTimer = null;

function findUserByNick(nick) {
  // Search active channel first, then all channels
  const state = channels.get(activeChannel);
  if (state) {
    for (const u of state.users.values()) {
      if (u.nick === nick) return { user: u, channel: activeChannel, chState: state };
    }
  }
  for (const [chName, ch] of channels) {
    for (const u of ch.users.values()) {
      if (u.nick === nick) return { user: u, channel: chName, chState: ch };
    }
  }
  return null;
}

function getLastTxTime(nick) {
  const state = channels.get(activeChannel);
  if (!state) return null;
  for (let i = state.messages.length - 1; i >= 0; i--) {
    if (state.messages[i].nick === nick) return state.messages[i].date || null;
  }
  return null;
}

function countTx(nick) {
  const state = channels.get(activeChannel);
  if (!state) return 0;
  let n = 0;
  for (const m of state.messages) { if (m.nick === nick) n++; }
  return n;
}

function showNickTooltip(nick, el) {
  clearTimeout(tooltipTimer);
  const found = findUserByNick(nick);
  if (!found) return;
  const { user, chState } = found;

  const sysName = systemNames.get(user.systemId) || `System ${user.systemId}`;
  const online = user.online !== false;
  const statusHtml = online
    ? '<span class="tt-online">online</span>'
    : '<span class="tt-offline">offline</span>';
  const lastTx = getLastTxTime(nick);
  const txCount = countTx(nick);

  let html = `<span class="tt-nick">${esc(nick)}</span><br>`;
  html += `<span class="tt-label">Unit:</span> ${user.unitId}<br>`;
  html += `<span class="tt-label">System:</span> ${esc(sysName)}<br>`;
  html += `<span class="tt-label">Status:</span> ${statusHtml}`;
  if (user.role === 'op') html += ` <span class="tt-label">(op)</span>`;
  if (txCount > 0) {
    html += `<br><span class="tt-label">TX in history:</span> ${txCount}`;
  }
  if (lastTx) {
    html += `<br><span class="tt-label">Last TX:</span> ${ts(lastTx)}`;
  }

  nickTooltip.innerHTML = html;
  nickTooltip.style.display = 'block';

  const rect = el.getBoundingClientRect();
  let left = rect.right + 8;
  let top = rect.top;

  // If tooltip would overflow right side, position to the left
  const ttWidth = nickTooltip.offsetWidth;
  if (left + ttWidth > window.innerWidth - 10) {
    left = rect.left - ttWidth - 8;
  }
  // Keep within viewport vertically
  const ttHeight = nickTooltip.offsetHeight;
  if (top + ttHeight > window.innerHeight - 10) {
    top = window.innerHeight - ttHeight - 10;
  }

  nickTooltip.style.left = left + 'px';
  nickTooltip.style.top = top + 'px';
}

function hideNickTooltip() {
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(() => { nickTooltip.style.display = 'none'; }, 100);
}

/** Format frequency in MHz */
function fmtFreq(hz) {
  if (!hz) return '';
  return (hz / 1e6).toFixed(4) + ' MHz';
}

/** Format duration */
function fmtDuration(sec) {
  if (!sec && sec !== 0) return '';
  if (sec < 60) return sec.toFixed(1) + 's';
  return Math.floor(sec / 60) + 'm' + Math.floor(sec % 60) + 's';
}

/** Fuzzy channel match: exact → substring → stripped alphanumeric substring */
function fuzzyMatchChannel(input) {
  const exact = '#' + input;
  if (channels.has(exact)) return exact;

  const lower = input.toLowerCase();
  // Substring match on channel name
  for (const name of channels.keys()) {
    if (name.toLowerCase().includes(lower)) return name;
  }

  // Strip non-alphanumeric from both input and channel names, then substring match
  const stripped = lower.replace(/[^a-z0-9]/g, '');
  if (!stripped) return null;
  let best = null;
  let bestLen = Infinity;
  for (const name of channels.keys()) {
    const nameStripped = name.toLowerCase().replace(/[^a-z0-9]/g, '');
    if (nameStripped.includes(stripped)) {
      // Prefer shortest match (most specific)
      if (nameStripped.length < bestLen) {
        best = name;
        bestLen = nameStripped.length;
      }
    }
  }
  return best;
}

/** Composite key for tgid lookup */
function tgKey(systemId, tgid) { return `${systemId}:${tgid}`; }
function unitKey(systemId, unitId) { return `${systemId}:${unitId}`; }


// ══════════════════════════════════════════════════════════════
// CHANNEL MANAGEMENT
// ══════════════════════════════════════════════════════════════

function initStatusChannel() {
  channels.set(STATUS_CHANNEL, {
    tgid: null, system_id: null,
    alpha_tag: 'status', description: 'Server messages',
    tag: '', group: 'System', mode: '',
    users: new Map(), messages: [],
  });
  channelUnread.set(STATUS_CHANNEL, 0);
}

function ensureChannel(tg) {
  const key = tgKey(tg.system_id, tg.tgid);
  if (tgidToChannel.has(key)) return tgidToChannel.get(key);

  if (tg.system_name && !systemNames.has(tg.system_id)) systemNames.set(tg.system_id, tg.system_name);
  const chanName = toChannelName(tg.alpha_tag || tg.tg_alpha_tag);

  // Handle collisions — append tgid if needed
  let finalName = chanName;
  if (channels.has(finalName)) {
    const existing = channels.get(finalName);
    if (existing.tgid !== tg.tgid || existing.system_id !== tg.system_id) {
      finalName = chanName + '-' + tg.tgid;
    }
  }

  if (!channels.has(finalName)) {
    channels.set(finalName, {
      tgid: tg.tgid,
      system_id: tg.system_id,
      alpha_tag: tg.alpha_tag || tg.tg_alpha_tag || `TG ${tg.tgid}`,
      description: tg.description || tg.tg_description || '',
      tag: tg.tag || tg.tg_tag || '',
      group: tg.group || tg.tg_group || 'Ungrouped',
      mode: '+nt',
      users: new Map(),
      messages: [],
      historyOffset: 0,
      historyExhausted: false,
    });
    channelUnread.set(finalName, 0);
  }

  tgidToChannel.set(key, finalName);
  return finalName;
}

function resolveChannel(systemId, tgid) {
  return tgidToChannel.get(tgKey(systemId, tgid));
}

function resolveNick(systemId, unitId, alphaTag) {
  const key = unitKey(systemId, unitId);
  if (alphaTag && alphaTag.trim()) {
    const nick = toNick(alphaTag, unitId);
    unitNickCache.set(key, nick);
    return nick;
  }
  if (unitNickCache.has(key)) return unitNickCache.get(key);
  const fallback = toNick(null, unitId);
  unitNickCache.set(key, fallback);
  return fallback;
}


// ══════════════════════════════════════════════════════════════
// MESSAGE RENDERING
// ══════════════════════════════════════════════════════════════

function addMsg(channel, msg) {
  const state = channels.get(channel);
  if (!state) return;

  state.messages.push(msg);
  if (state.messages.length > MAX_MESSAGES) {
    state.messages.shift();
    if (channel === activeChannel) messagesEl.firstChild?.remove();
  }

  // Track live activity — real messages (not notices/topic/mode) promote channels
  if (msg.kind !== 'notice' && msg.kind !== 'topic' && msg.kind !== 'mode') {
    if (!channelHasActivity.has(channel)) {
      channelHasActivity.add(channel);
      renderTree();
    }
  }

  if (channel === activeChannel) {
    appendMsgDOM(msg);
    // Auto-scroll if near bottom
    const atBottom = messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < 80;
    if (atBottom) messagesEl.scrollTop = messagesEl.scrollHeight;
  } else {
    channelUnread.set(channel, (channelUnread.get(channel) || 0) + 1);
    renderTree();
  }

  eventRate.push(Date.now());
}

function appendMsgDOM(m) {
  // Date separator between days (local midnight boundaries)
  const msgDate = m.date || new Date();
  const dateStr = `${msgDate.getFullYear()}-${msgDate.getMonth()}-${msgDate.getDate()}`;
  if (lastRenderedDateStr && dateStr !== lastRenderedDateStr) {
    const sep = document.createElement('div');
    sep.className = 'date-separator';
    sep.textContent = formatDateSeparator(msgDate);
    messagesEl.appendChild(sep);
  }
  lastRenderedDateStr = dateStr;

  const div = document.createElement('div');
  let classes = 'msg';
  if (m.kind) classes += ` ${m.kind}`;
  if (m.emergency) classes += ' emergency';
  if (m.encrypted) classes += ' encrypted';
  div.className = classes;

  const isSystem = ['join', 'part', 'quit', 'mode', 'topic', 'notice'].includes(m.kind);
  const isAction = m.kind === 'action';

  if (isSystem) {
    div.innerHTML = `<span class="ts">${esc(m.ts)}</span><span class="prefix">***</span><span class="body"> ${esc(m.text)}</span>`;
    div.classList.add('system');
  } else if (isAction) {
    div.innerHTML = `<span class="ts">${esc(m.ts)}</span><span class="prefix">*</span><span class="body"> ${esc(m.nick)} ${esc(m.text)}</span>`;
    div.classList.add('system');
  } else {
    const color = nickColor(m.nick || '');
    const nickHtml = `<span class="ts">${esc(m.ts)}</span><span class="nick" style="color:${color}" data-nick="${esc(m.nick || '')}">${esc(m.nick || '???')}</span>`;

    // Voice message with audio link
    if (m.callId) {
      const dur = m.duration || '';
      const body = document.createElement('span');
      body.className = 'body';

      const play = document.createElement('span');
      play.className = 'voice-play';
      play.textContent = '▶';
      body.appendChild(play);

      if (dur) {
        const durSpan = document.createElement('span');
        durSpan.className = 'voice-dur';
        durSpan.textContent = ' ' + dur + ' ';
        body.appendChild(durSpan);
      }

      const listen = document.createElement('a');
      listen.className = 'voice-listen';
      listen.textContent = 'listen';
      listen.href = '#';
      listen.dataset.callId = m.callId;
      listen.dataset.nick = m.nick || '';
      listen.dataset.channel = m.channel || '';
      listen.dataset.dur = dur;
      listen.addEventListener('click', (e) => {
        e.preventDefault();
        playCall(m.callId, m.nick, m.channel, div);
      });
      body.appendChild(listen);

      div.innerHTML = nickHtml;
      div.appendChild(body);
    } else {
      div.innerHTML = nickHtml + `<span class="body">${esc(m.text)}</span>`;
    }
  }

  // Call grouping: if consecutive messages share the same callId, bracket them
  if (m.callId) {
    div.dataset.callId = m.callId;
    const prev = messagesEl.lastElementChild;
    if (prev && prev.dataset.callId === String(m.callId)) {
      // Previous message is part of the same call
      if (prev.classList.contains('call-group-last')) {
        prev.classList.replace('call-group-last', 'call-group-mid');
      } else if (!prev.classList.contains('call-group-first') && !prev.classList.contains('call-group-mid')) {
        prev.classList.add('call-group-first');
      }
      div.classList.add('call-group-last');
    }
  }

  messagesEl.appendChild(div);
}

function esc(s) {
  if (!s) return '';
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function serverMsg(text) {
  addMsg(STATUS_CHANNEL, { ts: ts(), kind: 'notice', text });
}

function serverMsgTo(channel, text) {
  addMsg(channel, { ts: ts(), kind: 'notice', text });
}


// ══════════════════════════════════════════════════════════════
// TYPING INDICATOR
// ══════════════════════════════════════════════════════════════

function showTyping(channel, nick) {
  const existing = typingState.get(channel);
  if (existing) clearTimeout(existing.timeout);

  const timeout = setTimeout(() => {
    typingState.delete(channel);
    if (channel === activeChannel) typingBar.innerHTML = '';
  }, TYPING_DURATION);

  typingState.set(channel, { nick, timeout });
  if (channel === activeChannel) {
    typingBar.innerHTML = `<span class="typing-nick">${esc(nick)}</span> is typing...`;
  }
}

function clearTyping(channel) {
  const existing = typingState.get(channel);
  if (existing) {
    clearTimeout(existing.timeout);
    typingState.delete(channel);
    if (channel === activeChannel) typingBar.innerHTML = '';
  }
}


// ══════════════════════════════════════════════════════════════
// CHANNEL TREE
// ══════════════════════════════════════════════════════════════

function groupLabelHtml(name) {
  // Split into county prefix and category; only allow line-break between them
  const m = name.match(/^(.*?\(\d+\))\s(.+)$/);
  if (m) return `<span class="nb">${esc(m[1])}</span> <wbr><span class="nb">${esc(m[2])}</span>`;
  return esc(name);
}

function createChannelItem(ch) {
  const el = document.createElement('div');
  const unread = channelUnread.get(ch) || 0;
  el.className = 'channel-item' + (ch === activeChannel ? ' active' : '') + (unread > 0 && ch !== activeChannel ? ' has-activity' : '');
  el.innerHTML = `<span class="chan-prefix">#</span><span class="chan-label">${esc(ch.slice(1))}</span>`;
  if (unread > 0 && ch !== activeChannel) {
    el.innerHTML += `<span class="unread">${unread > 99 ? '99+' : unread}</span>`;
  }
  el.addEventListener('click', () => switchChannel(ch));
  return el;
}

function isChannelActive(ch) {
  return channelHasActivity.has(ch) || ch === activeChannel || (channelUnread.get(ch) || 0) > 0;
}

function renderTree() {
  // Group channels by group field
  const groups = new Map();
  for (const [name, ch] of channels) {
    if (name === STATUS_CHANNEL) continue;
    const g = ch.group || 'Ungrouped';
    if (!groups.has(g)) groups.set(g, []);
    groups.get(g).push(name);
  }

  treeScroll.innerHTML = '';

  // Status channel first
  const sysSection = document.createElement('div');
  sysSection.className = 'tree-section';
  const sysLabel = document.createElement('div');
  sysLabel.className = 'tree-section-label';
  sysLabel.textContent = 'System';
  sysSection.appendChild(sysLabel);

  const statusItem = document.createElement('div');
  statusItem.className = 'channel-item' + (activeChannel === STATUS_CHANNEL ? ' active' : '');
  statusItem.innerHTML = `<span class="chan-prefix">*</span><span class="chan-label">status</span>`;
  if (channelUnread.get(STATUS_CHANNEL) > 0 && activeChannel !== STATUS_CHANNEL) {
    statusItem.classList.add('has-activity');
  }
  statusItem.addEventListener('click', () => switchChannel(STATUS_CHANNEL));
  sysSection.appendChild(statusItem);
  treeScroll.appendChild(sysSection);

  // Sort groups alphabetically
  const sortedGroups = [...groups.entries()].sort((a, b) => a[0].localeCompare(b[0]));

  for (const [groupName, chans] of sortedGroups) {
    const section = document.createElement('div');
    section.className = 'tree-section';

    // Sort channels within group
    chans.sort();

    // Split into active and inactive channels
    const activeChans = chans.filter(ch => isChannelActive(ch));
    const inactiveChans = chans.filter(ch => !isChannelActive(ch));

    const isExpanded = groupCollapsed.get(groupName) === true; // explicitly expanded
    const allInactive = activeChans.length === 0;

    const label = document.createElement('div');
    label.className = 'tree-section-label';

    if (allInactive && !isExpanded) {
      if (chans.length <= 3) {
        // Small inactive group — show all channels directly
        label.innerHTML = groupLabelHtml(groupName);
        label.addEventListener('click', () => {
          groupCollapsed.set(groupName, false);
          renderTree();
        });
        section.appendChild(label);
        for (const ch of chans) {
          section.appendChild(createChannelItem(ch));
        }
      } else {
        // Large inactive group — collapse with "N more..."
        label.classList.add('collapsed');
        label.innerHTML = groupLabelHtml(groupName);
        label.addEventListener('click', () => {
          groupCollapsed.set(groupName, true);
          renderTree();
        });
        section.appendChild(label);

        const more = document.createElement('div');
        more.className = 'tree-more';
        more.textContent = `${chans.length} more...`;
        more.addEventListener('click', (e) => {
          e.stopPropagation();
          groupCollapsed.set(groupName, true);
          renderTree();
        });
        section.appendChild(more);
      }
    } else if (isExpanded) {
      // Fully expanded — show all channels
      label.innerHTML = groupLabelHtml(groupName);
      label.addEventListener('click', () => {
        groupCollapsed.set(groupName, false);
        renderTree();
      });
      section.appendChild(label);

      for (const ch of chans) {
        section.appendChild(createChannelItem(ch));
      }
    } else {
      // Mixed: show active channels + "N more..." expander for inactive
      label.innerHTML = groupLabelHtml(groupName);
      label.addEventListener('click', () => {
        groupCollapsed.set(groupName, true);
        renderTree();
      });
      section.appendChild(label);

      for (const ch of activeChans) {
        section.appendChild(createChannelItem(ch));
      }

      if (inactiveChans.length > 0 && inactiveChans.length <= 3) {
        for (const ch of inactiveChans) {
          section.appendChild(createChannelItem(ch));
        }
      } else if (inactiveChans.length > 3) {
        const more = document.createElement('div');
        more.className = 'tree-more';
        more.textContent = `${inactiveChans.length} more...`;
        more.addEventListener('click', (e) => {
          e.stopPropagation();
          groupCollapsed.set(groupName, true);
          renderTree();
        });
        section.appendChild(more);
      }
    }

    treeScroll.appendChild(section);
  }
}


// ══════════════════════════════════════════════════════════════
// NICKLIST
// ══════════════════════════════════════════════════════════════

function renderNicklist() {
  const state = channels.get(activeChannel);
  if (!state) {
    nicklistHeader.textContent = 'Users';
    nicklistEntries.innerHTML = '';
    return;
  }

  const users = [...state.users.values()];
  // Sort: online first, then alphabetical within each group
  const sortUser = (a, b) => {
    const ao = a.online === false ? 1 : 0;
    const bo = b.online === false ? 1 : 0;
    if (ao !== bo) return ao - bo;
    return a.nick.localeCompare(b.nick);
  };
  const ops = users.filter(u => u.role === 'op').sort(sortUser);
  const voiced = users.filter(u => u.role === 'voice').sort(sortUser);
  const regular = users.filter(u => u.role === 'regular').sort(sortUser);
  const onlineCount = users.filter(u => u.online !== false).length;

  // Collect nicks that have spoken in the displayed history
  const talkedNicks = new Set();
  for (const m of state.messages) {
    if (m.nick) talkedNicks.add(m.nick);
  }

  nicklistHeader.textContent = `Users (${onlineCount}/${users.length})`;
  nicklistEntries.innerHTML = '';

  function addSection(label, list, cls, prefix) {
    if (list.length === 0) return;
    const lbl = document.createElement('div');
    lbl.className = 'nicklist-section-label';
    lbl.textContent = `${label} (${list.length})`;
    nicklistEntries.appendChild(lbl);
    for (const u of list) {
      const el = document.createElement('div');
      el.className = `nick-item ${cls}` + (u.online === false ? ' offline' : '') + (talkedNicks.has(u.nick) ? ' talked' : '');
      el.innerHTML = `<span class="nick-prefix">${prefix}</span>${esc(u.nick)}`;
      el.addEventListener('mouseenter', () => showNickTooltip(u.nick, el));
      el.addEventListener('mouseleave', hideNickTooltip);
      nicklistEntries.appendChild(el);
    }
  }

  addSection('Ops', ops, 'op', '@');
  addSection('Voiced', voiced, 'voice', '+');
  addSection('Users', regular, 'regular', ' ');

  chanCountEl.textContent = `${onlineCount}/${users.length} users`;
}


// ══════════════════════════════════════════════════════════════
// CHANNEL SWITCHING
// ══════════════════════════════════════════════════════════════

function switchChannel(ch) {
  if (!channels.has(ch)) return;
  activeChannel = ch;
  channelUnread.set(ch, 0);

  const state = channels.get(ch);
  const displayName = ch;
  const topic = state.description || state.tag || '';

  chanNameEl.textContent = displayName;
  chanTopicEl.textContent = topic;
  chanModeEl.textContent = state.mode ? `[${state.mode}]` : '';
  titlebarChan.textContent = displayName;
  titlebarTopic.textContent = topic;
  inputPrompt.textContent = `[${displayName}]`;

  // Render messages
  messagesEl.innerHTML = '';
  lastRenderedDateStr = '';
  for (const m of state.messages) appendMsgDOM(m);
  messagesEl.scrollTop = messagesEl.scrollHeight;

  // Load history if this channel hasn't been populated yet, or fill viewport
  if (state.tgid && !channelLoading.has(ch)) {
    if (!channelHasActivity.has(ch)) {
      lazyLoadChannel(ch, state.system_id, state.tgid).then(() => ensureChannelFilled(ch));
    } else {
      ensureChannelFilled(ch);
    }
  }

  // Typing
  const t = typingState.get(ch);
  if (t) typingBar.innerHTML = `<span class="typing-nick">${esc(t.nick)}</span> is typing...`;
  else typingBar.innerHTML = '';

  renderTree();
  renderNicklist();
}

/** Convert API calls into message objects for a channel. Returns messages oldest-first. Deduplicates by call_id. */
function callsToMessages(calls, chanName, systemId) {
  const msgs = [];
  const ch = channels.get(chanName);
  if (!channelLoadedCallIds.has(chanName)) channelLoadedCallIds.set(chanName, new Set());
  const loadedIds = channelLoadedCallIds.get(chanName);
  const sorted = [...calls].reverse(); // API returns newest-first; flip to oldest-first
  for (const call of sorted) {
    if (loadedIds.has(call.call_id)) continue;
    loadedIds.add(call.call_id);
    const srcList = call.src_list || [];
    const isEmergency = call.emergency || false;
    const sid = call.system_id || systemId;

    if (call.encrypted) {
      const units = call.units || [];
      const srcNick = units.length > 0
        ? resolveNick(sid, units[0].unit_id, units[0].alpha_tag)
        : (call.tg_alpha_tag || `TG ${call.tgid}`);
      const callTime = call.start_time ? new Date(call.start_time) : new Date();
      const dur = call.duration ? fmtDuration(call.duration) : '';
      msgs.push({
        ts: ts(callTime), date: callTime, nick: srcNick, encrypted: true,
        text: `[encrypted${dur ? ', ' + dur : ''}]`,
      });
    } else if (srcList.length > 0) {
      const txSorted = [...srcList].sort((a, b) => (a.pos || 0) - (b.pos || 0));
      for (const tx of txSorted) {
        const nick = resolveNick(sid, tx.src, tx.tag);
        const txTime = tx.time ? new Date(tx.time * 1000) : (call.start_time ? new Date(call.start_time) : new Date());
        const dur = tx.duration ? fmtDuration(tx.duration) : '';
        if (ch) ensureUserInChannel(ch, chanName, sid, tx.src, tx.tag);
        msgs.push({
          ts: ts(txTime), date: txTime, nick, callId: call.call_id,
          duration: dur, channel: chanName,
          emergency: isEmergency || tx.emergency === 1,
        });
      }
    } else {
      const units = call.units || [];
      const srcNick = units.length > 0
        ? resolveNick(sid, units[0].unit_id, units[0].alpha_tag)
        : (call.tg_alpha_tag || `TG ${call.tgid}`);
      const callTime = call.start_time ? new Date(call.start_time) : new Date();
      const dur = call.duration ? fmtDuration(call.duration) : '';
      msgs.push({
        ts: ts(callTime), date: callTime, nick: srcNick, callId: call.call_id,
        duration: dur, channel: chanName, emergency: isEmergency,
      });
    }
  }
  return msgs;
}

const HISTORY_PAGE_SIZE = 50;

async function lazyLoadChannel(chanName, systemId, tgid) {
  channelLoading.add(chanName);
  const ch = channels.get(chanName);
  if (!ch) { channelLoading.delete(chanName); return; }

  try {
    const data = await fetchJSON(`/calls?tgid=${tgid}&system_id=${systemId}&sort=-stop_time&deduplicate=true&limit=${HISTORY_PAGE_SIZE}&offset=${ch.historyOffset}`);
    const calls = data.calls || [];

    if (calls.length < HISTORY_PAGE_SIZE) ch.historyExhausted = true;
    ch.historyOffset += calls.length;

    if (calls.length === 0) {
      channelLoading.delete(chanName);
      return;
    }

    const newMsgs = callsToMessages(calls, chanName, systemId);

    // Prepend older messages to the beginning of the channel's messages array
    ch.messages.unshift(...newMsgs);

    // Trim excess from the end if needed
    while (ch.messages.length > MAX_MESSAGES) ch.messages.pop();

    channelHasActivity.add(chanName);

    // Re-render if still on this channel, preserving scroll position
    if (activeChannel === chanName) {
      const prevScrollTop = messagesEl.scrollTop;
      const prevScrollHeight = messagesEl.scrollHeight;
      const wasAtBottom = prevScrollHeight - prevScrollTop - messagesEl.clientHeight < 80;
      messagesEl.innerHTML = '';
      lastRenderedDateStr = '';
      for (const m of ch.messages) appendMsgDOM(m);
      const newScrollHeight = messagesEl.scrollHeight;
      if (wasAtBottom && prevScrollHeight <= messagesEl.clientHeight) {
        // First load or content didn't fill viewport — scroll to bottom
        messagesEl.scrollTop = newScrollHeight;
      } else {
        // Preserve view: offset by the height of prepended content
        messagesEl.scrollTop = prevScrollTop + (newScrollHeight - prevScrollHeight);
      }
      renderNicklist();
    }
    renderTree();
  } catch (err) {
    serverMsgTo(chanName, `Failed to load history: ${err.message}`);
  } finally {
    channelLoading.delete(chanName);
  }
}


/** Keep loading older history until the messages area is scrollable or data is exhausted. */
async function ensureChannelFilled(chanName) {
  const ch = channels.get(chanName);
  if (!ch || !ch.tgid || ch.historyExhausted || channelLoading.has(chanName)) return;
  if (activeChannel !== chanName) return;

  // If content already fills the viewport, nothing to do
  if (messagesEl.scrollHeight > messagesEl.clientHeight + 40) return;

  await lazyLoadChannel(chanName, ch.system_id, ch.tgid);

  // Recurse until filled or exhausted
  if (activeChannel === chanName && !ch.historyExhausted) {
    ensureChannelFilled(chanName);
  }
}

// Scroll-to-top handler: load older messages when scrolling up
messagesEl.addEventListener('scroll', () => {
  if (messagesEl.scrollTop > 100) return; // not near top
  if (!activeChannel || activeChannel === STATUS_CHANNEL) return;
  const ch = channels.get(activeChannel);
  if (!ch || !ch.tgid || ch.historyExhausted || channelLoading.has(activeChannel)) return;
  lazyLoadChannel(activeChannel, ch.system_id, ch.tgid);
});


// ══════════════════════════════════════════════════════════════
// API FETCHING — Bootstrap channels & nicklists
// ══════════════════════════════════════════════════════════════

async function fetchJSON(path) {
  const res = await fetch(API_BASE + path);
  if (!res.ok) throw new Error(`${res.status} ${res.statusText} from ${path}`);
  return res.json();
}

async function bootstrapChannels() {
  serverMsg(`Fetching channel list from ${API_BASE}/talkgroups...`);
  try {
    const data = await fetchJSON('/talkgroups?limit=1000&sort=alpha_tag');
    const tgs = data.talkgroups || [];
    serverMsg(`Received ${tgs.length} talkgroups`);

    for (const tg of tgs) {
      const chanName = ensureChannel(tg);
      // Initial join message
      channels.get(chanName).messages.push({
        ts: ts(), kind: 'notice',
        text: `Now talking on ${chanName}`,
      });
      channels.get(chanName).messages.push({
        ts: ts(), kind: 'topic',
        text: `Topic for ${chanName}: ${tg.description || tg.alpha_tag} [${tg.tag || ''}]`,
      });
      if (tg.mode) {
        channels.get(chanName).messages.push({
          ts: ts(), kind: 'mode',
          text: `${chanName} mode: ${tg.mode}`,
        });
      }
    }

    serverMsg(`Joined ${channels.size - 1} channels`);
    renderTree();

    // Auto-switch to first real channel
    const firstChan = [...channels.keys()].find(k => k !== STATUS_CHANNEL);
    if (firstChan) switchChannel(firstChan);
  } catch (err) {
    serverMsg(`ERROR fetching talkgroups: ${err.message}`);
  }
}

async function bootstrapAffiliations() {
  serverMsg('Fetching user affiliations...');
  try {
    const data = await fetchJSON('/unit-affiliations?limit=5000');
    const affs = data.affiliations || [];
    serverMsg(`Received ${affs.length} affiliations`);

    let userCount = 0;
    let offlineCount = 0;
    for (const aff of affs) {
      const chanName = resolveChannel(aff.system_id, aff.tgid);
      if (!chanName) continue;

      const ch = channels.get(chanName);
      if (!ch) continue;

      const nick = resolveNick(aff.system_id, aff.unit_id, aff.unit_alpha_tag);
      const role = roleForNick(nick);
      const prefix = role === 'op' ? '@' : '';
      const online = aff.status === 'affiliated';

      if (!ch.users.has(aff.unit_id)) {
        ch.users.set(aff.unit_id, { nick, prefix, role, unitId: aff.unit_id, systemId: aff.system_id, online });
        userCount++;
        if (!online) offlineCount++;
      }
    }

    serverMsg(`${userCount} users loaded across channels (${userCount - offlineCount} online, ${offlineCount} offline)`);
    renderNicklist();
    renderTree();
  } catch (err) {
    serverMsg(`ERROR fetching affiliations: ${err.message}`);
  }
}

async function bootstrapRecentCalls() {
  serverMsg('Fetching recent activity (30 min)...');
  try {
    const since = new Date(Date.now() - 30 * 60 * 1000).toISOString();
    const data = await fetchJSON(`/calls?sort=-stop_time&deduplicate=true&limit=500&start_time=${since}`);
    const calls = data.calls || [];

    // Track which channels got backfill messages (for unread counts)
    const backfillCounts = new Map();

    // Replay recent calls as message history (oldest first)
    const sorted = [...calls].reverse();
    for (const call of sorted) {
      const chanName = resolveChannel(call.system_id, call.tgid);
      if (!chanName) continue;
      const ch = channels.get(chanName);
      if (!ch) continue;

      // Track call ID for dedup with lazy load
      if (!channelLoadedCallIds.has(chanName)) channelLoadedCallIds.set(chanName, new Set());
      channelLoadedCallIds.get(chanName).add(call.call_id);
      ch.historyOffset++;

      const systemId = call.system_id;
      const srcList = call.src_list || [];
      const isEmergency = call.emergency || false;
      let msgCount = 0;

      if (call.encrypted) {
        // Encrypted: show single line
        const units = call.units || [];
        const srcNick = units.length > 0
          ? resolveNick(systemId, units[0].unit_id, units[0].alpha_tag)
          : (call.tg_alpha_tag || `TG ${call.tgid}`);
        const callTime = call.start_time ? new Date(call.start_time) : new Date();
        const dur = call.duration ? fmtDuration(call.duration) : '';

        ch.messages.push({
          ts: ts(callTime), date: callTime, nick: srcNick, encrypted: true,
          text: `[encrypted${dur ? ', ' + dur : ''}]`,
        });
        msgCount = 1;
      } else if (srcList.length > 0) {
        // Per-transmission messages sorted by position
        const txSorted = [...srcList].sort((a, b) => (a.pos || 0) - (b.pos || 0));

        for (const tx of txSorted) {
          const nick = resolveNick(systemId, tx.src, tx.tag);
          const txTime = tx.time ? new Date(tx.time * 1000) : (call.start_time ? new Date(call.start_time) : new Date());
          const dur = tx.duration ? fmtDuration(tx.duration) : '';
          const txEmergency = tx.emergency === 1;

          // Ensure unit in nicklist
          ensureUserInChannel(ch, chanName, systemId, tx.src, tx.tag);

          ch.messages.push({
            ts: ts(txTime), date: txTime,
            nick,
            callId: call.call_id,
            duration: dur,
            channel: chanName,
            emergency: isEmergency || txEmergency,
          });
          msgCount++;
        }
      } else {
        // Fallback: no src_list
        const units = call.units || [];
        const srcNick = units.length > 0
          ? resolveNick(systemId, units[0].unit_id, units[0].alpha_tag)
          : (call.tg_alpha_tag || `TG ${call.tgid}`);
        const callTime = call.start_time ? new Date(call.start_time) : new Date();
        const dur = call.duration ? fmtDuration(call.duration) : '';

        ch.messages.push({
          ts: ts(callTime), date: callTime, nick: srcNick,
          callId: call.call_id,
          duration: dur,
          channel: chanName,
          emergency: isEmergency,
        });
        msgCount = 1;
      }

      if (msgCount > 0) {
        backfillCounts.set(chanName, (backfillCounts.get(chanName) || 0) + msgCount);
      }
    }

    // Set unread badges and activity flags for channels with backfill
    for (const [chanName, count] of backfillCounts) {
      channelHasActivity.add(chanName);
      // Don't set unread for the currently active channel
      if (chanName !== activeChannel) {
        channelUnread.set(chanName, count);
      }
    }

    serverMsg(`Loaded ${calls.length} recent calls across ${backfillCounts.size} channels`);

    // Re-render if we're on a channel that got backfill
    if (activeChannel !== STATUS_CHANNEL) {
      messagesEl.innerHTML = '';
      lastRenderedDateStr = '';
      const state = channels.get(activeChannel);
      if (state) {
        for (const m of state.messages) appendMsgDOM(m);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }
    }

    renderTree();
  } catch (err) {
    serverMsg(`ERROR fetching recent calls: ${err.message}`);
  }
}


// ══════════════════════════════════════════════════════════════
// SSE — Real-time event stream
// ══════════════════════════════════════════════════════════════

function connectSSE() {
  if (sseConnection) {
    sseConnection.close();
    sseConnection = null;
  }

  setConnectionState('connecting');

  const url = `${API_BASE}/events/stream`;
  serverMsg(`Connecting to ${url}...`);

  const es = new EventSource(url);
  sseConnection = es;

  es.onopen = () => {
    setConnectionState('connected');
    serverMsg('Connected to event stream');
  };

  es.onerror = () => {
    if (connectionState === 'connected') {
      serverMsg('Connection lost, reconnecting...');
    }
    setConnectionState('disconnected');
    // EventSource auto-reconnects
  };

  // ── Call events ──
  es.addEventListener('call_start', (e) => {
    lastEventId = e.lastEventId;
    const call = JSON.parse(e.data);
    handleCallStart(call);
  });

  es.addEventListener('call_update', (e) => {
    lastEventId = e.lastEventId;
    const call = JSON.parse(e.data);
    handleCallUpdate(call);
  });

  es.addEventListener('call_end', (e) => {
    lastEventId = e.lastEventId;
    const call = JSON.parse(e.data);
    handleCallEnd(call);
  });

  // ── Unit events ──
  es.addEventListener('unit_event', (e) => {
    lastEventId = e.lastEventId;
    const evt = JSON.parse(e.data);
    handleUnitEvent(evt);
  });

  // ── Recorder updates (optional, show as server notices) ──
  es.addEventListener('recorder_update', (e) => {
    // Silent — could log to *status if desired
  });

  es.addEventListener('rate_update', (e) => {
    lastEventId = e.lastEventId;
    const data = JSON.parse(e.data);
    if (data.decode_rate !== undefined) {
      const pct = (data.decode_rate * 100).toFixed(1);
      titlebarLag.textContent = `decode: ${pct}%`;
    }
  });
}

function setConnectionState(state) {
  connectionState = state;
  const dot = treeStatus.querySelector('.dot');

  if (state === 'connected') {
    treeStatus.innerHTML = '<span class="dot connected"></span>Connected';
    statusDot.className = 'status-ok';
    statusDot.textContent = '●';
  } else if (state === 'connecting') {
    treeStatus.innerHTML = '<span class="dot connecting"></span>Connecting...';
    statusDot.className = 'status-err';
    statusDot.textContent = '○';
  } else {
    treeStatus.innerHTML = '<span class="dot disconnected"></span>Disconnected';
    statusDot.className = 'status-err';
    statusDot.textContent = '●';
  }
}


// ══════════════════════════════════════════════════════════════
// EVENT HANDLERS — Map SSE events to IRC actions
// ══════════════════════════════════════════════════════════════

function handleCallStart(call) {
  // Ensure channel exists
  const chanName = ensureChannel({
    system_id: call.system_id, tgid: call.tgid,
    alpha_tag: call.tg_alpha_tag, description: call.tg_description,
    tag: call.tg_tag, group: call.tg_group,
  });

  const ch = channels.get(chanName);
  if (!ch) return;

  // Identify first speaker from src_list (preferred) or units fallback
  const srcList = call.src_list || [];
  const units = call.units || [];
  let srcNick = null;

  if (srcList.length > 0) {
    srcNick = resolveNick(call.system_id, srcList[0].src, srcList[0].tag);
    ensureUserInChannel(ch, chanName, call.system_id, srcList[0].src, srcList[0].tag);
  } else if (units.length > 0) {
    srcNick = resolveNick(call.system_id, units[0].unit_id, units[0].alpha_tag);
    ensureUserInChannel(ch, chanName, call.system_id, units[0].unit_id, units[0].alpha_tag);
  }

  // Track active call — store src count so call_update can detect new transmissions
  activeCalls.set(call.call_id, {
    tgid: call.tgid, system_id: call.system_id,
    chanName, start: Date.now(),
    srcCount: srcList.length,
  });

  // Show typing indicator for primary speaker
  if (srcNick) showTyping(chanName, srcNick);

  // Emergency handling
  if (call.emergency) {
    addMsg(chanName, {
      ts: ts(), kind: 'notice', emergency: true,
      text: `*** EMERGENCY *** ${srcNick || 'unknown'} — emergency call on ${chanName}`,
    });
  }

  // Encrypted call — show immediately since we won't get transcript content
  if (call.encrypted) {
    const dur = srcList.length > 0 && srcList[0].duration ? fmtDuration(srcList[0].duration) : '';
    addMsg(chanName, {
      ts: ts(), nick: srcNick || chanName, encrypted: true,
      text: `[encrypted${dur ? ', ' + dur : ''}]`,
    });
    clearTyping(chanName);
  }

  renderTree();
}

/** Ensure a unit is in a channel's nicklist */
function ensureUserInChannel(ch, chanName, systemId, unitId, alphaTag) {
  if (ch.users.has(unitId)) {
    // Mark online if they're transmitting
    const u = ch.users.get(unitId);
    if (u.online === false) { u.online = true; if (chanName === activeChannel) renderNicklist(); }
    return;
  }
  const nick = resolveNick(systemId, unitId, alphaTag);
  const role = roleForNick(nick);
  ch.users.set(unitId, { nick, prefix: role === 'op' ? '@' : '', role, unitId, systemId, online: true });
  if (chanName === activeChannel) renderNicklist();
}

function handleCallUpdate(call) {
  const tracked = activeCalls.get(call.call_id);
  if (!tracked) return;

  const chanName = tracked.chanName;
  const ch = channels.get(chanName);
  if (!ch) return;

  const srcList = call.src_list || [];
  const systemId = call.system_id || tracked.system_id;

  // Detect new transmissions added since last update
  if (srcList.length > tracked.srcCount) {
    // New key-ups since we last saw this call
    for (let i = tracked.srcCount; i < srcList.length; i++) {
      const tx = srcList[i];
      const nick = resolveNick(systemId, tx.src, tx.tag);
      ensureUserInChannel(ch, chanName, systemId, tx.src, tx.tag);
      showTyping(chanName, nick);
    }
    tracked.srcCount = srcList.length;
  } else if (srcList.length > 0) {
    // No new transmissions, but refresh typing for latest speaker
    const last = srcList[srcList.length - 1];
    showTyping(chanName, resolveNick(systemId, last.src, last.tag));
  }

  // Also pick up any new units from the units array
  const units = call.units || [];
  for (const u of units) {
    ensureUserInChannel(ch, chanName, systemId, u.unit_id, u.alpha_tag);
  }
}

function handleCallEnd(call) {
  const tracked = activeCalls.get(call.call_id);
  activeCalls.delete(call.call_id);

  const chanName = tracked
    ? tracked.chanName
    : resolveChannel(call.system_id, call.tgid);
  if (!chanName) return;

  clearTyping(chanName);

  const ch = channels.get(chanName);
  if (!ch) return;

  const isEmergency = call.emergency || false;

  if (call.encrypted) {
    // Already showed encrypted notice on call_start
    return;
  }

  const srcList = call.src_list || [];
  if (srcList.length > 0) {
    // src_list available — render per-unit messages immediately
    renderCallTransmissions(chanName, call.call_id, call.system_id, srcList, isEmergency);
  } else {
    // src_list not in call_end SSE — fetch full call after audio processing
    setTimeout(() => fetchAndRenderCall(call.call_id, chanName, call.system_id, isEmergency, call), 2500);
  }
}

/** Fetch the full call record from the API and render per-unit messages. */
async function fetchAndRenderCall(callId, chanName, systemId, isEmergency, fallbackCall) {
  const ch = channels.get(chanName);
  if (!ch) return;

  try {
    const data = await fetchJSON(`/calls/${callId}`);
    const srcList = data.src_list || [];
    if (srcList.length > 0) {
      renderCallTransmissions(chanName, callId, data.system_id || systemId, srcList, data.emergency || isEmergency);
      return;
    }
  } catch (err) {
    // API fetch failed — fall through to fallback
  }

  // Fallback: no src_list even after fetch
  const dur = fallbackCall.duration ? fmtDuration(fallbackCall.duration) : '';
  const nick = fallbackCall.tg_alpha_tag || `TG ${fallbackCall.tgid}`;
  addMsg(chanName, {
    ts: ts(), nick,
    callId: fallbackCall.call_id,
    duration: dur,
    channel: chanName,
    emergency: isEmergency,
  });
}

/** Render per-transmission voice messages from a call's src_list. */
function renderCallTransmissions(chanName, callId, systemId, srcList, isEmergency) {
  const ch = channels.get(chanName);
  if (!ch) return;

  const sorted = [...srcList].sort((a, b) => (a.pos || 0) - (b.pos || 0));
  for (const tx of sorted) {
    const nick = resolveNick(systemId, tx.src, tx.tag);
    ensureUserInChannel(ch, chanName, systemId, tx.src, tx.tag);

    const txTime = tx.time ? new Date(tx.time * 1000) : new Date();
    const dur = tx.duration ? fmtDuration(tx.duration) : '';
    const txEmergency = tx.emergency === 1;

    addMsg(chanName, {
      ts: ts(txTime), date: txTime,
      nick,
      callId,
      duration: dur,
      channel: chanName,
      emergency: isEmergency || txEmergency,
    });
  }
}

function handleUnitEvent(evt) {
  const systemId = evt.system_id;
  const unitId = evt.unit_id;
  const nick = resolveNick(systemId, unitId, evt.unit_alpha_tag);
  const tgid = evt.tgid;

  // Resolve or create channel
  let chanName = tgid ? resolveChannel(systemId, tgid) : null;
  if (!chanName && tgid) {
    chanName = ensureChannel({
      system_id: systemId, tgid,
      alpha_tag: evt.tg_alpha_tag, description: evt.tg_description,
      tag: '', group: 'Ungrouped',
    });
    renderTree();
  }

  switch (evt.event_type) {
    case 'join': {
      // Talkgroup affiliation → IRC JOIN
      if (!chanName) break;
      const ch = channels.get(chanName);
      if (!ch) break;

      if (!ch.users.has(unitId)) {
        const role = roleForNick(nick);
        ch.users.set(unitId, { nick, prefix: role === 'op' ? '@' : '', role, unitId, systemId, affiliated: true, online: true });

        addMsg(chanName, {
          ts: ts(), kind: 'join',
          text: `${nick} has joined ${chanName}${ch.tag ? ' [' + ch.tag + ']' : ''}`,
        });
        if (chanName === activeChannel) renderNicklist();
      } else {
        // Mark as affiliated and online
        const u = ch.users.get(unitId);
        u.affiliated = true;
        u.online = true;
        if (chanName === activeChannel) renderNicklist();
      }
      break;
    }

    case 'off': {
      // Unit deregistration → mark offline (dimmed in nicklist)
      let found = false;
      for (const [chName, ch] of channels) {
        if (ch.users.has(unitId)) {
          const u = ch.users.get(unitId);
          u.online = false;
          addMsg(chName, {
            ts: ts(), kind: 'quit',
            text: `${nick} has quit (Quit)`,
          });
          found = true;
          if (chName === activeChannel) renderNicklist();
        }
      }
      if (!found) {
        serverMsg(`${nick} has disconnected`);
      }
      break;
    }

    case 'on': {
      // Unit registration → mark online in any channels it's in
      let found = false;
      for (const [chName, ch] of channels) {
        if (ch.users.has(unitId)) {
          const u = ch.users.get(unitId);
          u.online = true;
          found = true;
          if (chName === activeChannel) renderNicklist();
        }
      }
      serverMsg(`${nick} has connected to the network`);
      break;
    }

    case 'call': {
      // Channel grant / voice call — show typing
      if (chanName) {
        showTyping(chanName, nick);
        // Temporarily add user to channel if not already present (e.g. patched talkgroup)
        const ch = channels.get(chanName);
        if (ch && !ch.users.has(unitId)) {
          const role = roleForNick(nick);
          ch.users.set(unitId, { nick, prefix: role === 'op' ? '@' : '', role, unitId, systemId, affiliated: false, online: true });
          if (chanName === activeChannel) renderNicklist();
        }
      }
      break;
    }

    case 'end': {
      // Per-unit end of transmission — remove from channel if not affiliated
      if (chanName) {
        clearTyping(chanName);
        const ch = channels.get(chanName);
        if (ch) {
          const u = ch.users.get(unitId);
          if (u && !u.affiliated) {
            ch.users.delete(unitId);
            if (chanName === activeChannel) renderNicklist();
          }
        }
      }
      break;
    }

    case 'location': {
      // Silent — could show as CTCP or notice
      break;
    }

    case 'ackresp':
    case 'data':
    case 'ans_req': {
      // Data/signaling — silent
      break;
    }

    default:
      break;
  }
}


// ══════════════════════════════════════════════════════════════
// INPUT HANDLING — IRC commands
// ══════════════════════════════════════════════════════════════

document.addEventListener('keydown', (e) => {
  if (e.key === '/' && document.activeElement !== inputField) {
    e.preventDefault();
    inputField.focus();
    inputField.value = '/';
  }
});

// Nick tooltip on hover in chat messages (event delegation)
messagesEl.addEventListener('mouseover', (e) => {
  const nickEl = e.target.closest('.nick[data-nick]');
  if (nickEl && nickEl.dataset.nick) showNickTooltip(nickEl.dataset.nick, nickEl);
});
messagesEl.addEventListener('mouseout', (e) => {
  const nickEl = e.target.closest('.nick[data-nick]');
  if (nickEl) hideNickTooltip();
});

inputField.addEventListener('keydown', (e) => {
  if (e.key !== 'Enter') return;
  const val = inputField.value.trim();
  inputField.value = '';
  if (!val) return;

  if (val.startsWith('/')) {
    handleCommand(val);
  } else {
    // Read-only: can't send messages to radio channels
    addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'This client is read-only (Layer 1). Messages cannot be sent.' });
  }
});

function handleCommand(cmd) {
  const parts = cmd.split(/\s+/);
  const c = parts[0].toLowerCase();

  switch (c) {
    case '/j':
    case '/join': {
      const target = parts[1];
      if (!target) { addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Usage: /join #channel' }); break; }
      const raw = target.startsWith('#') ? target.slice(1) : target;
      const match = fuzzyMatchChannel(raw);
      if (match) {
        switchChannel(match);
      } else {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `No such channel: #${raw}` });
      }
      break;
    }

    case '/part':
    case '/leave': {
      switchChannel(STATUS_CHANNEL);
      break;
    }

    case '/list':
    case '/channels': {
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '— Channel list —' });
      for (const [name, ch] of channels) {
        if (name === STATUS_CHANNEL) continue;
        addMsg(activeChannel, {
          ts: ts(), kind: 'notice',
          text: `  ${name}  (${ch.users.size} users) — ${ch.description || ch.alpha_tag}`,
        });
      }
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `— End of /list — ${channels.size - 1} channels` });
      break;
    }

    case '/who':
    case '/names': {
      const target = parts[1] || activeChannel;
      let ch = channels.get(target);
      if (!ch) {
        // Fuzzy
        for (const [name, c] of channels) {
          if (name.toLowerCase().includes(target.toLowerCase())) { ch = c; break; }
        }
      }
      if (!ch) { addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `No such channel: ${target}` }); break; }
      const nicks = [...ch.users.values()].map(u => `${u.prefix}${u.nick}`).join(' ');
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `[${target}] ${nicks || '(empty)'}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `— End of /NAMES — ${ch.users.size} total` });
      break;
    }

    case '/topic': {
      const ch = channels.get(activeChannel);
      if (ch) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Topic for ${activeChannel}: ${ch.description || ch.alpha_tag}` });
      }
      break;
    }

    case '/whois': {
      const target = parts[1];
      if (!target) { addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Usage: /whois <nick>' }); break; }
      const lower = target.toLowerCase();
      const onChans = [];
      for (const [name, ch] of channels) {
        for (const u of ch.users.values()) {
          if (u.nick.toLowerCase() === lower) { onChans.push(name); break; }
        }
      }
      if (onChans.length > 0) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `[${target}] is on channels: ${onChans.join(' ')}` });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `[${target}] connected via tr-engine` });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `— End of /WHOIS —` });
      } else {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `No such nick: ${target}` });
      }
      break;
    }

    case '/ops': {
      const opArgs = parts.slice(1).join(' ').trim();
      if (!opArgs) {
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Op patterns: ${getOpPatterns()}` });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'Usage: /ops <pattern1>,<pattern2>,... (regex, comma-separated)' });
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '/ops reset — restore defaults' });
      } else if (opArgs === 'reset') {
        localStorage.removeItem('op_patterns');
        opRegex = buildOpRegex(DEFAULT_OP_PATTERNS);
        reapplyRoles();
        addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Op patterns reset to: ${DEFAULT_OP_PATTERNS}` });
      } else {
        try {
          const testRe = buildOpRegex(opArgs);
          testRe.test('test'); // validate
          localStorage.setItem('op_patterns', opArgs);
          opRegex = testRe;
          reapplyRoles();
          addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Op patterns set to: ${opArgs}` });
        } catch (e) {
          addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Invalid regex: ${e.message}` });
        }
      }
      break;
    }

    case '/readall':
      markAllRead();
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: 'All channels marked as read' });
      break;

    case '/clear':
      if (channels.has(activeChannel)) {
        channels.get(activeChannel).messages = [];
        messagesEl.innerHTML = '';
        lastRenderedDateStr = '';
      }
      break;

    case '/reconnect':
      connectSSE();
      break;

    case '/api':
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `API base: ${API_BASE}` });
      break;

    case '/stats': {
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '— Stats —' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Channels: ${channels.size - 1}` });
      let totalU = 0;
      const uniqueNicks = new Set();
      for (const ch of channels.values()) {
        for (const u of ch.users.values()) uniqueNicks.add(u.nick);
        totalU += ch.users.size;
      }
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Unique users: ${uniqueNicks.size}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Total affiliations: ${totalU}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Active calls: ${activeCalls.size}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `  Connection: ${connectionState}` });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '— End of /stats —' });
      break;
    }

    case '/nerd': {
      const enabled = document.documentElement.classList.toggle('nerd');
      localStorage.setItem('nerd_mode', enabled ? '1' : '0');
      addMsg(activeChannel, { ts: ts(), kind: 'notice',
        text: `Hipster nerd cool mode ${enabled ? 'enabled ✨' : 'disabled'}` });
      break;
    }

    case '/help':
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '— Commands —' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /j, /join #channel  — Switch to channel (fuzzy match)' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /part               — Switch to *status' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /list               — List all channels' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /who, /names        — List users in channel' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /whois <nick>       — User info' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /topic              — Show channel topic' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /stats              — Connection & channel stats' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /ops [patterns]     — View/set op nick patterns (comma-sep regex)' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /readall            — Mark all channels as read' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /reconnect          — Reconnect SSE stream' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /clear              — Clear scrollback' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /api                — Show API base URL' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '  /nerd               — Toggle hipster nerd cool mode (small text, low contrast)' });
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: '— End of /help —' });
      break;

    default:
      addMsg(activeChannel, { ts: ts(), kind: 'notice', text: `Unknown command: ${c}` });
  }
}


// ══════════════════════════════════════════════════════════════
// STATUS BAR
// ══════════════════════════════════════════════════════════════

function updateStatusBar() {
  statusTime.textContent = tsLong();
  statusChannelsEl.textContent = `${channels.size - 1} channels`;

  const now = Date.now();
  eventRate = eventRate.filter(t => now - t < 60000);
  statusRate.textContent = eventRate.length;

  const uniqueNicks = new Set();
  for (const ch of channels.values()) {
    for (const u of ch.users.values()) uniqueNicks.add(u.nick);
  }
  statusUsersEl.textContent = `${uniqueNicks.size} users`;
}


// ══════════════════════════════════════════════════════════════
// AUDIO PLAYER
// ══════════════════════════════════════════════════════════════

const playerBar = document.getElementById('player-bar');
const playerPlayBtn = document.getElementById('player-play');
const playerNickEl = document.getElementById('player-nick');
const playerChanEl = document.getElementById('player-chan');
const playerTimeEl = document.getElementById('player-time');
const playerProgress = document.getElementById('player-progress');
const playerProgressFill = document.getElementById('player-progress-fill');
const playerCloseBtn = document.getElementById('player-close');

const audioEl = new Audio();
audioEl.preload = 'auto';
let currentPlayingMsgEl = null;
let currentCallId = null;
let playerRaf = null;

function fmtAudioTime(sec) {
  if (!sec || !isFinite(sec)) return '0:00';
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

function playCall(callId, nick, channel, msgEl) {
  // If clicking the same call that's playing, toggle pause
  if (currentCallId === callId && !audioEl.paused) {
    audioEl.pause();
    playerPlayBtn.textContent = '▶';
    return;
  }
  if (currentCallId === callId && audioEl.paused) {
    audioEl.play();
    playerPlayBtn.textContent = '⏸';
    return;
  }

  // New call — load and play
  currentCallId = callId;

  // Clear previous highlight
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = msgEl;
  if (msgEl) msgEl.classList.add('now-playing');

  // Update player bar
  playerNickEl.textContent = nick || '?';
  playerNickEl.style.color = nickColor(nick || '');
  playerChanEl.textContent = channel || '';
  playerTimeEl.textContent = '0:00 / --:--';
  playerProgressFill.style.width = '0%';
  playerBar.classList.add('active');
  playerPlayBtn.textContent = '⏳';

  // Load audio
  const audioUrl = `${API_BASE}/calls/${callId}/audio`;
  audioEl.src = audioUrl;
  audioEl.load();
  audioEl.play().then(() => {
    playerPlayBtn.textContent = '⏸';
    updatePlayerProgress();
  }).catch(err => {
    playerPlayBtn.textContent = '▶';
    playerTimeEl.textContent = err.name === 'NotAllowedError' ? 'click to play' : 'no audio';
    console.warn('Playback error:', err.message);
  });
}

function updatePlayerProgress() {
  if (playerRaf) cancelAnimationFrame(playerRaf);

  function tick() {
    if (!audioEl.paused && audioEl.duration) {
      const pct = (audioEl.currentTime / audioEl.duration) * 100;
      playerProgressFill.style.width = pct + '%';
      playerTimeEl.textContent = `${fmtAudioTime(audioEl.currentTime)} / ${fmtAudioTime(audioEl.duration)}`;
    }
    if (!audioEl.paused) playerRaf = requestAnimationFrame(tick);
  }
  tick();
}

// Play/pause button
playerPlayBtn.addEventListener('click', () => {
  if (!audioEl.src) return;
  if (audioEl.paused) {
    audioEl.play();
    playerPlayBtn.textContent = '⏸';
    updatePlayerProgress();
  } else {
    audioEl.pause();
    playerPlayBtn.textContent = '▶';
  }
});

// Close player
playerCloseBtn.addEventListener('click', () => {
  audioEl.pause();
  audioEl.src = '';
  currentCallId = null;
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = null;
  playerBar.classList.remove('active');
  if (playerRaf) cancelAnimationFrame(playerRaf);
});

// Seek on progress bar click
playerProgress.addEventListener('click', (e) => {
  if (!audioEl.duration) return;
  const rect = playerProgress.getBoundingClientRect();
  const pct = (e.clientX - rect.left) / rect.width;
  audioEl.currentTime = pct * audioEl.duration;
  playerProgressFill.style.width = (pct * 100) + '%';
});

// Audio ended
audioEl.addEventListener('ended', () => {
  playerPlayBtn.textContent = '▶';
  playerProgressFill.style.width = '100%';
  if (currentPlayingMsgEl) currentPlayingMsgEl.classList.remove('now-playing');
  currentPlayingMsgEl = null;
  currentCallId = null;
});

// Duration loaded
audioEl.addEventListener('loadedmetadata', () => {
  playerTimeEl.textContent = `0:00 / ${fmtAudioTime(audioEl.duration)}`;
});


// ══════════════════════════════════════════════════════════════
// READ ALL
// ══════════════════════════════════════════════════════════════

function markAllRead() {
  for (const key of channelUnread.keys()) {
    channelUnread.set(key, 0);
  }
  renderTree();
}

document.getElementById('read-all-btn').addEventListener('click', markAllRead);

// ── Nerd mode: restore from localStorage ──
if (localStorage.getItem('nerd_mode') === '1') {
  document.documentElement.classList.add('nerd');
}
document.getElementById('nerd-btn').addEventListener('click', () => {
  const enabled = document.documentElement.classList.toggle('nerd');
  localStorage.setItem('nerd_mode', enabled ? '1' : '0');
});


// ══════════════════════════════════════════════════════════════
// INIT
// ══════════════════════════════════════════════════════════════

async function init() {
  initStatusChannel();
  switchChannel(STATUS_CHANNEL);
  renderTree();

  serverMsg(`tr-engine IRC client — Layer 1 (read-only)`);
  serverMsg(`API: ${API_BASE}`);
  serverMsg('');

  // Bootstrap: channels → affiliations → recent calls → SSE
  await bootstrapChannels();
  await bootstrapAffiliations();
  await bootstrapRecentCalls();

  // Connect SSE for live events
  connectSSE();

  // Status bar ticker
  setInterval(updateStatusBar, 1000);
  updateStatusBar();
}

init();
inputField.focus();
</script>
</body>
</html>
