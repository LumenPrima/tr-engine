<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="card-title" content="Unit Tracker">
<meta name="card-description" content="Live unit status grid with state colors and activity">
<meta name="card-order" content="3">
<title>tr-engine units</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Outfit:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg-body: #0b0e14;
    --bg-card: #121620;
    --bg-card-hover: #161c28;
    --bg-header: #0d1019;
    --border: #1e2433;
    --border-active: #2a3548;
    --text-primary: #e2e8f0;
    --text-secondary: #8892a4;
    --text-dim: #5a6478;
    --accent-blue: #38bdf8;
    --accent-cyan: #00e5ff;
    --accent-violet: #a855f7;
    --accent-amber: #fbbf24;
    --accent-rose: #fb7185;
    --accent-green: #3fb950;
    --accent-slate: #94a3b8;
    --unit-active: #00e5ff;
    --unit-recent: #a855f7;
    --unit-affiliated: #38bdf8;
    --unit-location: #fbbf24;
    --unit-off: #64748b;
    --unit-data: #94a3b8;
    --unit-idle: #475569;
    --font-sans: 'Outfit', system-ui, -apple-system, sans-serif;
    --font-mono: 'JetBrains Mono', 'SF Mono', 'Consolas', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: var(--font-sans);
    background: var(--bg-body);
    color: var(--text-primary);
    font-size: 14px;
    min-height: 100vh;
  }

  /* --- Header --- */
  header {
    position: sticky; top: 0; z-index: 20;
    background: var(--bg-header);
    border-bottom: 1px solid var(--border);
    padding: 10px 20px;
    display: flex; align-items: center; gap: 16px; flex-wrap: wrap;
  }

  .logo {
    font-family: var(--font-mono);
    font-size: 14px; font-weight: 600;
    color: var(--text-primary);
    white-space: nowrap;
  }
  .logo span { color: var(--accent-cyan); }

  .status { display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--text-secondary); white-space: nowrap; }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .status-dot.connected { background: var(--accent-green); box-shadow: 0 0 6px var(--accent-green); }
  .status-dot.disconnected { background: var(--accent-rose); }
  .status-dot.connecting { background: var(--accent-amber); animation: pulse 1.2s ease-in-out infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

  .header-controls {
    display: flex; gap: 8px; align-items: center; flex-wrap: wrap; flex: 1; min-width: 0;
  }

  .filter-input {
    padding: 5px 10px; font-size: 12px;
    background: var(--bg-card); border: 1px solid var(--border); border-radius: 6px;
    color: var(--text-primary); font-family: var(--font-sans);
    outline: none; transition: border-color 0.2s;
  }
  .filter-input:focus { border-color: var(--accent-blue); }
  .filter-input::placeholder { color: var(--text-dim); }
  #filter-search { width: 180px; }
  #filter-system, #filter-group { width: 140px; }

  .stats {
    margin-left: auto; display: flex; gap: 14px;
    font-size: 12px; font-family: var(--font-mono); color: var(--text-secondary); white-space: nowrap;
  }
  .stats .num { color: var(--accent-cyan); font-weight: 600; }

  /* --- Auth --- */
  .auth-prompt {
    display: none; position: fixed; inset: 0;
    background: rgba(0,0,0,0.7); z-index: 100;
    align-items: center; justify-content: center;
  }
  .auth-prompt.visible { display: flex; }
  .auth-box {
    background: var(--bg-card); border: 1px solid var(--border); border-radius: 10px;
    padding: 28px; max-width: 380px; width: 92%;
  }
  .auth-box h2 { font-size: 16px; font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
  .auth-box p { font-size: 13px; color: var(--text-secondary); margin-bottom: 16px; }
  .auth-box input {
    width: 100%; padding: 8px 12px;
    background: var(--bg-body); border: 1px solid var(--border); border-radius: 6px;
    color: var(--text-primary); font-family: var(--font-mono); font-size: 13px; margin-bottom: 12px;
  }
  .auth-box input:focus { outline: none; border-color: var(--accent-blue); }
  .auth-box button {
    padding: 7px 20px; background: var(--accent-blue); border: none; border-radius: 6px;
    color: #000; font-size: 13px; font-weight: 600; cursor: pointer; transition: background 0.15s;
  }
  .auth-box button:hover { background: #5cc8fa; }

  /* --- Card Grid --- */
  #card-grid {
    padding: 16px 20px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 12px;
    align-content: start;
  }

  .tg-card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 12px 14px;
    transition: border-color 0.4s, box-shadow 0.4s;
    display: flex; flex-direction: column; gap: 8px;
  }
  .tg-card.active {
    border-color: var(--border-active);
    box-shadow: 0 0 12px rgba(0, 229, 255, 0.06);
  }
  .tg-card.emergency {
    border-color: var(--accent-rose);
    box-shadow: 0 0 16px rgba(251, 113, 133, 0.15);
  }
  .tg-card.hidden { display: none; }

  .tg-header {
    display: flex; justify-content: space-between; align-items: flex-start; gap: 8px;
  }
  .tg-name {
    font-size: 14px; font-weight: 600; color: var(--text-primary);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    flex: 1; min-width: 0;
  }
  .tg-id {
    font-family: var(--font-mono); font-size: 11px; font-weight: 600;
    color: var(--text-dim); background: rgba(255,255,255,0.04);
    padding: 2px 6px; border-radius: 4px; white-space: nowrap; flex-shrink: 0;
  }

  .tg-meta {
    display: flex; gap: 8px; flex-wrap: wrap;
    font-size: 11px; color: var(--text-secondary);
  }
  .tg-meta .tag {
    padding: 1px 6px; border-radius: 3px;
    background: rgba(255,255,255,0.04);
  }

  .tg-units {
    display: flex; flex-wrap: wrap; gap: 4px;
    min-height: 26px;
  }

  /* --- Unit Icons --- */
  .unit {
    display: inline-flex; align-items: center; justify-content: center;
    min-width: 40px; height: 26px; padding: 0 6px;
    border-radius: 5px; font-family: var(--font-mono);
    font-size: 10px; font-weight: 600;
    cursor: default; position: relative;
    transition: background-color 0.6s, opacity 0.6s, box-shadow 0.6s, transform 0.3s;
  }
  .unit:hover { transform: scale(1.1); z-index: 2; }

  .unit.state-active {
    background: rgba(0, 229, 255, 0.18);
    color: var(--unit-active);
    box-shadow: 0 0 8px rgba(0, 229, 255, 0.3);
  }
  .unit.state-recent {
    background: rgba(168, 85, 247, 0.18);
    color: var(--unit-recent);
  }
  .unit.state-affiliated {
    background: rgba(56, 189, 248, 0.14);
    color: var(--unit-affiliated);
  }
  .unit.state-location {
    background: rgba(251, 191, 36, 0.15);
    color: var(--unit-location);
  }
  .unit.state-off {
    background: rgba(100, 116, 139, 0.12);
    color: var(--unit-off);
    opacity: 0.5;
  }
  .unit.state-data {
    background: rgba(148, 163, 184, 0.12);
    color: var(--unit-data);
  }
  .unit.state-idle {
    background: rgba(71, 85, 105, 0.12);
    color: var(--unit-idle);
  }

  /* --- Tooltip --- */
  .unit[data-tip]:hover::after {
    content: attr(data-tip);
    position: absolute; bottom: calc(100% + 6px); left: 50%;
    transform: translateX(-50%);
    background: #1e293b; color: var(--text-primary);
    font-size: 11px; font-family: var(--font-sans);
    padding: 4px 8px; border-radius: 5px; white-space: nowrap;
    pointer-events: none; z-index: 10;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }

  /* --- Loading --- */
  #loading {
    display: flex; align-items: center; justify-content: center;
    padding: 80px 20px; color: var(--text-secondary); font-size: 14px;
    gap: 10px;
  }
  #loading.hidden { display: none; }
  .spinner {
    width: 18px; height: 18px; border: 2px solid var(--border);
    border-top-color: var(--accent-cyan); border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* --- Empty state --- */
  #empty-state {
    display: none; text-align: center; padding: 80px 20px;
    color: var(--text-dim); font-size: 14px;
  }
</style>
</head>
<body>

<header>
  <div class="logo">tr-engine <span>units</span></div>
  <div class="status">
    <div id="status-dot" class="status-dot connecting"></div>
    <span id="status-text">connecting...</span>
  </div>
  <div class="header-controls">
    <select id="filter-system" class="filter-input"><option value="">All systems</option></select>
    <select id="filter-group" class="filter-input"><option value="">All groups</option></select>
    <input id="filter-search" class="filter-input" type="text" placeholder="Search talkgroups...">
  </div>
  <div class="stats">
    <span><span id="stat-tg" class="num">0</span> talkgroups</span>
    <span><span id="stat-units" class="num">0</span> units</span>
    <span><span id="stat-events" class="num">0</span> events</span>
  </div>
</header>

<div id="loading"><div class="spinner"></div>Loading talkgroups...</div>
<div id="empty-state">No active talkgroups found. Waiting for events...</div>
<div id="card-grid"></div>

<div id="auth-prompt" class="auth-prompt">
  <div class="auth-box">
    <h2>Authentication Required</h2>
    <p>Enter your API token to connect.</p>
    <input id="auth-token" type="password" placeholder="Bearer token" autofocus>
    <button id="auth-submit">Connect</button>
  </div>
</div>

<script>
const API_BASE = '/api/v1';
const DECAY = { active: 5000, recent: 60000, location: 30000, data: 30000 };

// --- State ---
let authToken = localStorage.getItem('tr-engine-token') || '';
let eventSource = null;
let everConnected = false;
let totalEvents = 0;

// tgKey = "systemId:tgid"
// talkgroups: Map<tgKey, {systemId, tgid, alphaTag, group, tag, description, systemName, sysid, emergency, el}>
const talkgroups = new Map();
// units: Map<unitKey("systemId:unitId"), {systemId, unitId, alphaTag, state, tgKey, el, timers:{}}>
const units = new Map();

// DOM refs
const grid = document.getElementById('card-grid');
const loadingEl = document.getElementById('loading');
const emptyEl = document.getElementById('empty-state');
const statusDot = document.getElementById('status-dot');
const statusText = document.getElementById('status-text');
const statTg = document.getElementById('stat-tg');
const statUnits = document.getElementById('stat-units');
const statEvents = document.getElementById('stat-events');
const filterSystem = document.getElementById('filter-system');
const filterGroup = document.getElementById('filter-group');
const filterSearch = document.getElementById('filter-search');
const authPrompt = document.getElementById('auth-prompt');
const authTokenInput = document.getElementById('auth-token');
const authSubmitBtn = document.getElementById('auth-submit');

// --- Helpers ---
function authHeaders() {
  const h = {};
  if (authToken) h['Authorization'] = 'Bearer ' + authToken;
  return h;
}

function setStatus(state, text) {
  statusDot.className = 'status-dot ' + state;
  statusText.textContent = text;
}

function esc(s) {
  if (s == null) return '';
  const d = document.createElement('div');
  d.textContent = String(s);
  return d.innerHTML;
}

function updateStats() {
  statTg.textContent = talkgroups.size;
  let unitCount = 0;
  units.forEach(u => { if (u.state !== 'idle' || u.el) unitCount++; });
  statUnits.textContent = unitCount;
  statEvents.textContent = totalEvents;
}

// --- Talkgroup Card ---
function tgKey(systemId, tgid) { return systemId + ':' + tgid; }
function unitKey(systemId, unitId) { return systemId + ':' + unitId; }

function ensureTalkgroup(systemId, tgid, info) {
  const key = tgKey(systemId, tgid);
  if (talkgroups.has(key)) {
    const tg = talkgroups.get(key);
    // Update info if provided
    if (info) {
      if (info.alphaTag) tg.alphaTag = info.alphaTag;
      if (info.group) tg.group = info.group;
      if (info.tag) tg.tag = info.tag;
      if (info.description) tg.description = info.description;
      if (info.systemName) tg.systemName = info.systemName;
      if (info.sysid) tg.sysid = info.sysid;
      updateCardHeader(tg);
    }
    return tg;
  }

  const tg = {
    systemId, tgid, key,
    alphaTag: (info && info.alphaTag) || 'TG ' + tgid,
    group: (info && info.group) || '',
    tag: (info && info.tag) || '',
    description: (info && info.description) || '',
    systemName: (info && info.systemName) || '',
    sysid: (info && info.sysid) || '',
    emergency: false,
    el: null,
  };
  talkgroups.set(key, tg);
  createCardEl(tg);
  populateFilterOptions();
  updateStats();
  applyFilters();
  return tg;
}

function createCardEl(tg) {
  const card = document.createElement('div');
  card.className = 'tg-card';
  card.dataset.key = tg.key;
  card.innerHTML =
    `<div class="tg-header">` +
      `<div class="tg-name">${esc(tg.alphaTag)}</div>` +
      `<div class="tg-id">${tg.tgid}</div>` +
    `</div>` +
    `<div class="tg-meta">` +
      (tg.group ? `<span class="tag">${esc(tg.group)}</span>` : '') +
      (tg.systemName ? `<span class="tag">${esc(tg.systemName)}</span>` : '') +
    `</div>` +
    `<div class="tg-units" data-units></div>`;
  tg.el = card;
  grid.appendChild(card);
  emptyEl.style.display = 'none';
}

function updateCardHeader(tg) {
  if (!tg.el) return;
  const nameEl = tg.el.querySelector('.tg-name');
  const metaEl = tg.el.querySelector('.tg-meta');
  if (nameEl) nameEl.textContent = tg.alphaTag;
  if (metaEl) {
    metaEl.innerHTML =
      (tg.group ? `<span class="tag">${esc(tg.group)}</span>` : '') +
      (tg.systemName ? `<span class="tag">${esc(tg.systemName)}</span>` : '');
  }
}

function setCardEmergency(tg, on) {
  tg.emergency = on;
  if (tg.el) tg.el.classList.toggle('emergency', on);
}

function setCardActive(tg, on) {
  if (tg.el) tg.el.classList.toggle('active', on);
}

// --- Unit Icon ---
function ensureUnit(systemId, unitId, info) {
  const key = unitKey(systemId, unitId);
  if (units.has(key)) {
    const u = units.get(key);
    if (info && info.alphaTag) u.alphaTag = info.alphaTag;
    return u;
  }
  const u = {
    systemId, unitId, key,
    alphaTag: (info && info.alphaTag) || '',
    state: 'idle',
    tgKey: null,
    el: null,
    timers: {},
  };
  units.set(key, u);
  updateStats();
  return u;
}

function createUnitEl(u) {
  const el = document.createElement('div');
  el.className = 'unit state-' + u.state;
  el.textContent = u.unitId;
  el.dataset.key = u.key;
  const tip = u.alphaTag || ('Unit ' + u.unitId);
  el.setAttribute('data-tip', tip);
  u.el = el;
  return el;
}

function placeUnit(u, newTgKey) {
  // Remove from old card
  if (u.el && u.el.parentNode) {
    u.el.parentNode.removeChild(u.el);
  }
  u.tgKey = newTgKey;
  if (!newTgKey) return;

  const tg = talkgroups.get(newTgKey);
  if (!tg || !tg.el) return;

  if (!u.el) createUnitEl(u);
  const container = tg.el.querySelector('[data-units]');
  if (container) container.appendChild(u.el);
}

function setUnitState(u, newState) {
  // Clear any pending decay timers
  Object.values(u.timers).forEach(clearTimeout);
  u.timers = {};

  u.state = newState;
  if (u.el) {
    u.el.className = 'unit state-' + newState;
    const tip = u.alphaTag || ('Unit ' + u.unitId);
    u.el.setAttribute('data-tip', tip + ' [' + newState + ']');
  }

  // Schedule decay
  const decay = DECAY[newState];
  if (decay) {
    const nextState = newState === 'active' ? 'recent' : 'idle';
    u.timers[newState] = setTimeout(() => setUnitState(u, nextState), decay);
  }

  // Card active glow when any unit is active
  if (u.tgKey) {
    const tg = talkgroups.get(u.tgKey);
    if (tg) {
      const hasActive = Array.from(units.values()).some(
        uu => uu.tgKey === u.tgKey && (uu.state === 'active' || uu.state === 'recent')
      );
      setCardActive(tg, hasActive);
    }
  }

  updateStats();
}

// --- SSE Event Handling ---
function handleUnitEvent(evt) {
  const d = evt;
  const systemId = d.system_id;
  const unitId = d.unit_id;
  const eventType = d.event_type;
  const tgid = d.tgid;

  if (!systemId || !unitId || unitId < 0) return;

  const u = ensureUnit(systemId, unitId, {
    alphaTag: d.unit_alpha_tag,
  });

  // Determine target talkgroup (tgid=0 means no talkgroup context)
  let targetTgKey = u.tgKey;
  if (tgid && tgid > 0) {
    targetTgKey = tgKey(systemId, tgid);
    ensureTalkgroup(systemId, tgid, {
      alphaTag: d.tg_alpha_tag,
      description: d.tg_description,
      systemName: d.system_name,
    });
  }

  // Helper: move unit to target card if needed
  function maybePlaceUnit() {
    if (targetTgKey && targetTgKey !== u.tgKey) placeUnit(u, targetTgKey);
    else if (targetTgKey && !u.el) placeUnit(u, targetTgKey);
  }

  // State transition
  switch (eventType) {
    case 'call':
      maybePlaceUnit();
      setUnitState(u, 'active');
      break;
    case 'end':
      setUnitState(u, 'recent');
      break;
    case 'join':
      maybePlaceUnit();
      setUnitState(u, 'affiliated');
      break;
    case 'on':
      // 'on' often arrives with tgid=0 (unit powered on, no talkgroup yet)
      if (tgid && tgid > 0) maybePlaceUnit();
      setUnitState(u, 'affiliated');
      break;
    case 'off':
      setUnitState(u, 'off');
      break;
    case 'location':
      maybePlaceUnit();
      setUnitState(u, 'location');
      break;
    case 'ackresp':
    case 'data':
      maybePlaceUnit();
      setUnitState(u, 'data');
      break;
    default:
      if (targetTgKey && !u.el) maybePlaceUnit();
      break;
  }
}

function handleCallStart(d) {
  const systemId = d.system_id;
  const tgid = d.tgid;
  if (!systemId || !tgid) return;

  const tg = ensureTalkgroup(systemId, tgid, {
    alphaTag: d.tg_alpha_tag,
    group: d.tg_group,
    tag: d.tg_tag,
    description: d.tg_description,
    systemName: d.system_name,
    sysid: d.sysid,
  });

  if (d.emergency) setCardEmergency(tg, true);
  setCardActive(tg, true);

  // Place units from call data
  if (d.units && Array.isArray(d.units)) {
    d.units.forEach(cu => {
      const uid = cu.unit_id || cu.unit_rid;
      if (!uid) return;
      const u = ensureUnit(systemId, uid, { alphaTag: cu.unit_alpha_tag });
      const tk = tgKey(systemId, tgid);
      if (tk !== u.tgKey || !u.el) placeUnit(u, tk);
      setUnitState(u, 'active');
    });
  }
}

function handleCallEnd(d) {
  const systemId = d.system_id;
  const tgid = d.tgid;
  if (!systemId || !tgid) return;

  const tg = ensureTalkgroup(systemId, tgid, {
    alphaTag: d.tg_alpha_tag,
    group: d.tg_group,
    tag: d.tg_tag,
    description: d.tg_description,
    systemName: d.system_name,
  });

  if (d.emergency) {
    // Clear emergency after a delay
    setTimeout(() => setCardEmergency(tg, false), 15000);
  }

  // Transition all active units on this tg to recent
  const tk = tgKey(systemId, tgid);
  units.forEach(u => {
    if (u.tgKey === tk && u.state === 'active') {
      setUnitState(u, 'recent');
    }
  });
}

// --- Filters ---
const allSystems = new Set();
const allGroups = new Set();

function populateFilterOptions() {
  talkgroups.forEach(tg => {
    if (tg.systemName) allSystems.add(tg.systemName);
    if (tg.group) allGroups.add(tg.group);
  });

  const curSys = filterSystem.value;
  const curGrp = filterGroup.value;

  // Rebuild system options
  const sysOpts = ['<option value="">All systems</option>'];
  [...allSystems].sort().forEach(s => {
    sysOpts.push(`<option value="${esc(s)}">${esc(s)}</option>`);
  });
  filterSystem.innerHTML = sysOpts.join('');
  filterSystem.value = curSys;

  // Rebuild group options
  const grpOpts = ['<option value="">All groups</option>'];
  [...allGroups].sort().forEach(g => {
    grpOpts.push(`<option value="${esc(g)}">${esc(g)}</option>`);
  });
  filterGroup.innerHTML = grpOpts.join('');
  filterGroup.value = curGrp;
}

function applyFilters() {
  const sys = filterSystem.value;
  const grp = filterGroup.value;
  const q = filterSearch.value.trim().toLowerCase();

  talkgroups.forEach(tg => {
    if (!tg.el) return;
    let show = true;
    if (sys && tg.systemName !== sys) show = false;
    if (grp && tg.group !== grp) show = false;
    if (q) {
      const haystack = (tg.alphaTag + ' ' + tg.tgid + ' ' + tg.group + ' ' + tg.description).toLowerCase();
      if (!haystack.includes(q)) show = false;
    }
    tg.el.classList.toggle('hidden', !show);
  });
}

let filterDebounce = null;
filterSearch.addEventListener('input', () => {
  clearTimeout(filterDebounce);
  filterDebounce = setTimeout(applyFilters, 150);
});
filterSystem.addEventListener('change', applyFilters);
filterGroup.addEventListener('change', applyFilters);

// --- Bootstrap ---
let bootstrapOk = false; // true once REST fetch succeeds (no auth needed)

async function apiFetch(path) {
  let resp;
  try {
    resp = await fetch(API_BASE + path, { headers: authHeaders() });
  } catch (e) {
    throw new Error('network');
  }
  if (resp.status === 401 || resp.status === 403) {
    showAuth();
    throw new Error('auth');
  }
  if (!resp.ok) throw new Error('HTTP ' + resp.status);
  bootstrapOk = true;
  return resp.json();
}

async function bootstrap() {
  loadingEl.classList.remove('hidden');
  emptyEl.style.display = 'none';

  try {
    // Fetch active talkgroups sorted by recent call activity
    const tgData = await apiFetch('/talkgroups?sort=-calls_1h&limit=200');
    const tgList = tgData.talkgroups || [];

    if (tgList.length === 0) {
      loadingEl.classList.add('hidden');
      emptyEl.style.display = 'block';
      connectSSE();
      return;
    }

    // Create cards for talkgroups with recent activity
    const activeTgs = tgList.filter(t => t.calls_1h > 0 || t.calls_24h > 0);
    const toShow = activeTgs.length > 0 ? activeTgs : tgList.slice(0, 30);

    toShow.forEach(t => {
      ensureTalkgroup(t.system_id, t.tgid, {
        alphaTag: t.alpha_tag,
        group: t.group,
        tag: t.tag,
        description: t.description,
        systemName: t.system_name,
        sysid: t.sysid,
      });
    });

    loadingEl.classList.add('hidden');

    // Fan out unit fetches for talkgroups with recent calls (max 10 concurrent)
    const tgsWithCalls = toShow.filter(t => t.calls_1h > 0);
    const queue = tgsWithCalls.slice(0, 50);
    const concurrency = 10;
    let idx = 0;

    async function fetchNext() {
      while (idx < queue.length) {
        const t = queue[idx++];
        try {
          const id = t.system_id + ':' + t.tgid;
          const unitData = await apiFetch('/talkgroups/' + encodeURIComponent(id) + '/units?window=60&limit=100');
          const unitList = unitData.units || [];
          const tk = tgKey(t.system_id, t.tgid);

          unitList.forEach(u => {
            if (!u.unit_id || u.unit_id < 0) return;
            const unit = ensureUnit(t.system_id, u.unit_id, {
              alphaTag: u.alpha_tag,
            });
            if (!unit.el || unit.tgKey !== tk) {
              placeUnit(unit, tk);
            }
            // Set initial state from last event
            const evtType = u.last_event_type;
            if (evtType === 'call') setUnitState(unit, 'recent');
            else if (evtType === 'end') setUnitState(unit, 'recent');
            else if (evtType === 'join' || evtType === 'on') setUnitState(unit, 'affiliated');
            else if (evtType === 'off') setUnitState(unit, 'off');
            else if (evtType === 'location') setUnitState(unit, 'location');
            else if (evtType === 'ackresp' || evtType === 'data') setUnitState(unit, 'data');
            else setUnitState(unit, 'idle');
          });
        } catch (e) {
          if (e.message === 'auth') return;
          console.warn('Failed to fetch units for tg', t.tgid, e);
        }
      }
    }

    const workers = [];
    for (let i = 0; i < Math.min(concurrency, queue.length); i++) {
      workers.push(fetchNext());
    }
    await Promise.all(workers);

    connectSSE();
  } catch (e) {
    loadingEl.classList.add('hidden');
    if (e.message === 'auth') return;
    console.error('Bootstrap failed:', e);
    emptyEl.style.display = 'block';
    emptyEl.textContent = 'Failed to load talkgroups. Connecting to live stream...';
    connectSSE();
  }
}

// --- SSE ---
function connectSSE() {
  if (eventSource) eventSource.close();

  const params = new URLSearchParams();
  params.set('types', 'unit_event,call_start,call_end');
  if (authToken) params.set('token', authToken);
  const url = API_BASE + '/events/stream?' + params.toString();

  setStatus('connecting', 'connecting...');
  everConnected = false;
  eventSource = new EventSource(url);

  eventSource.onopen = () => {
    setStatus('connected', 'connected');
    hideAuth();
    everConnected = true;
  };

  eventSource.onerror = () => {
    if (eventSource.readyState === EventSource.CLOSED) {
      setStatus('disconnected', 'disconnected');
      if (!everConnected && !bootstrapOk) {
        // REST also failed â€” likely auth issue
        eventSource.close();
        showAuth();
      }
    } else {
      setStatus('connecting', 'reconnecting...');
    }
  };

  eventSource.addEventListener('unit_event', (e) => {
    totalEvents++;
    statEvents.textContent = totalEvents;
    try {
      handleUnitEvent(JSON.parse(e.data));
    } catch (err) { console.error('unit_event parse error', err); }
  });

  eventSource.addEventListener('call_start', (e) => {
    totalEvents++;
    statEvents.textContent = totalEvents;
    try {
      handleCallStart(JSON.parse(e.data));
    } catch (err) { console.error('call_start parse error', err); }
  });

  eventSource.addEventListener('call_end', (e) => {
    totalEvents++;
    statEvents.textContent = totalEvents;
    try {
      handleCallEnd(JSON.parse(e.data));
    } catch (err) { console.error('call_end parse error', err); }
  });
}

// --- Auth ---
function showAuth() {
  authPrompt.classList.add('visible');
  authTokenInput.value = authToken;
  authTokenInput.focus();
}

function hideAuth() {
  authPrompt.classList.remove('visible');
}

authSubmitBtn.addEventListener('click', () => {
  authToken = authTokenInput.value.trim();
  localStorage.setItem('tr-engine-token', authToken);
  hideAuth();
  bootstrap();
});

authTokenInput.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') authSubmitBtn.click();
});

// --- Start ---
bootstrap();
</script>
</body>
</html>
